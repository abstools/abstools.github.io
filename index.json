[
{
	"uri": "http://abs-models.org/getting_started/local-install/",
	"title": "Installing Command-Line Tools",
	"tags": [],
	"description": "",
	"content": " Many of the tools can be run from the command line. This chapter describes how to run various tools on a local machine.\nInstalling the ABS Compiler To install the ABS compiler, install the Java 8 JDK and Erlang (version 21 or higher). Then, clone the git repository and build the compiler:\ngit clone https://github.com/abstools/abstools.git cd abstools/frontend ./gradlew assemble  After a successful build, there is an absc shell script in the abstools/frontend/bin/bash/ directory that invokes the ABS compiler. For Windows, there is abstools/frontend/bin/win/absc.bat. After adding that directory to your path environment variable, you can invoke absc on one or more abs source files with a command like absc -erlang model.abs.\nInstalling KeY-ABS For a local installation of the KeY-ABS theorem prover, install Java 8. Then, download KeY-ABS from http://i12www.ira.uka.de/key/key-abs/key-abs.zip. Unzipping that downloaded file and double-clicking on the key.jar file should start KeY-ABS. To start from the command line, use:\njava -jar key.jar  "
},
{
	"uri": "http://abs-models.org/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": " DESIGN PRINCIPLES OF ABS ABS targets the modeling of software systems that are concurrent, distributed, object-oriented, built from components, and highly reusable. To achieve the latter, we follow the arguably most successful software reuse methodology in practice: software product families or software product lines [35], see also the Product Line Hall of Fame. ABS supports the modeling of variability in terms of feature models as a first-class language concept. ABS thus provides language-based support for product line engineering (PLE).\nAs an abstract language ABS is well suited to model software that is supposed to be deployed in a virtualized environment. To close the gap between design and deployment it is necessary to represent low-level concepts such as system time, memory, latency, or scheduling at the level of abstract models. In ABS this is possible via a flexible and pluggable notation called deployment components, covered in detail in [24].\nABS is not merely a modeling notation, but it arrives with an integrated tool set that helps to automate the software engineering process. Tools are useless, however, unless they ensure predictability of results, interoperability, and usability. A fundamental requirement for the first two criteria is a uniform, formal semantics. But interoperability also involves the capability to connect with other notations than ABS. This is ensured by providing numerous language interfaces from and to ABS. These are realized by various import, export, and code generation tools.\nArguably the most important criterion for tools, however, is usability. This tutorial is not the place to embark on a full discussion of what that entails, but it should be indisputable that automation, scalability, and integration are of the utmost importance. To ensure the first two of these qualities, the HATS project adopted as a central principle to develop ABS in tandem with its tool set. This is not merely a historical footnote, but central to an understanding of the trade-offs made in the design of the ABS language. For most specification and programming languages their (automatic) analyzability is considered in hindsight and turns out not to be scalable or even feasible. With ABS, the slogan of design for verifiability that originated in the context of hardware description languages [30], has been systematically applied to a software modeling language. For example, the concurrency model of ABS is designed such that it permits a compositional proof system [3], the reuse principle employed in ABS is chosen in such a way that incremental verification is possible [21], etc. Many formal methods tools focus on analysis, in particular, on verification. Functional verification, model checking, test case generation, and resource estimation are supported by ABS tools as well. Just as important as analytic methods, specifically in a model-based context, are generative ones: ABS is fully executable (albeit in a non-deterministic manner) and supports code generation to Erlang and Maude.\n  ABS language architecture\n  In addition to the simulation tools, a number of analysis and generation tools are available as well. An overview of the ABS tool suite is given in [42].\n"
},
{
	"uri": "http://abs-models.org/getting_started/docker/",
	"title": "Running a Browser-Based IDE",
	"tags": [],
	"description": "",
	"content": " The collaboratory is a browser-based development environment for ABS. It integrates an editor, the syntax checker and simulator, and the SACO resource analysis tool.\nRunning the Collaboratory using Docker To run the collaboratory, first install docker from https://www.docker.com. Then, run the following command in a terminal window:\ndocker run -d --rm -p 8080:80 --name collaboratory abslang/collaboratory:latest  When the command has finished, connect a browser to http://localhost:8080 and start using ABS!\nTo stop the collaboratory, use the following command:\ndocker stop collaboratory  "
},
{
	"uri": "http://abs-models.org/getting_started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " There are various ways of running ABS models.\nUse On-Line Tools The simplest way to use the ABS tools is on-line, in the collaboratory. This means you only need a modern browser to start experimenting with ABS. The tools work best with Firefox and Chrome.\nAn introduction and link to the collaboratory can be found at http://abs-models.org/laboratory/.\n Installing Command-Line Tools  Many of the tools can be run from the command line. This chapter describes how to run various tools on a local machine. Installing the ABS Compiler To install the ABS compiler, install the Java 8 JDK and Erlang (version 21 or higher). Then, clone the git repository and build the compiler: git clone https://github.com/abstools/abstools.git cd abstools/frontend ./gradlew assemble After a successful build, there is an absc shell script in the abstools/frontend/bin/bash/ directory that invokes the ABS compiler.\n Running a Browser-Based IDE  The collaboratory is a browser-based development environment for ABS. It integrates an editor, the syntax checker and simulator, and the SACO resource analysis tool. Running the Collaboratory using Docker To run the collaboratory, first install docker from https://www.docker.com. Then, run the following command in a terminal window: docker run -d --rm -p 8080:80 --name collaboratory abslang/collaboratory:latest When the command has finished, connect a browser to http://localhost:8080 and start using ABS!\n Installing Editor Support  We provide support for Emacs, Atom and Visual Studio Code. Emacs The abs-mode package provides support for ABS in the Emacs editor. Installation instructions are at https://github.com/abstools/abs-mode. Atom The Atom editor support can be found at https://github.com/abstools/language-abs. ABS support for Atom currently cannot be installed from the offical Package repository and has to be installed manually; see https://github.com/abstools/language-abs for instructions. Visual Studio Code ABS editing support for Visual Studio Code is at https://github.\n "
},
{
	"uri": "http://abs-models.org/getting_started/editor-support/",
	"title": "Installing Editor Support",
	"tags": [],
	"description": "",
	"content": " We provide support for Emacs, Atom and Visual Studio Code.\nEmacs The abs-mode package provides support for ABS in the Emacs editor.\nInstallation instructions are at https://github.com/abstools/abs-mode.\nAtom The Atom editor support can be found at https://github.com/abstools/language-abs. ABS support for Atom currently cannot be installed from the offical Package repository and has to be installed manually; see https://github.com/abstools/language-abs for instructions.\nVisual Studio Code ABS editing support for Visual Studio Code is at https://github.com/abstools/abs-vs-code. It currently has to be installed manually; see the above page for instructions.\n"
},
{
	"uri": "http://abs-models.org/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Envisage Tutorials These tutorials were written during the Envisage project. These pdfs are provided as-is and might contain outdated information.\nInstallation Tutorial\nEasyInterface Tutorial\nBasic Tutorial\nResource Tutorial\nResource Analysis (SACO) Tutorial\nResource Analysis (SRA) Tutorial\nDeadlock Analysis (SACO) Tutorial\nDeadlock Analysis (SRA) Tutorial\nSystematic Testing (SYCO) \u0026amp; Test Case Generation (aPET) Tutorial\nSmart Deployer Tutorial\nKeY-ABS Tutorial\nModelling Auto-scalable Services Tutorial\nConverted Tutorials These tutorials have been checked. Conversion is on-going and help is most welcome.\n CostABS  CostABS is a a static analyzer for automatically inferring upper/lower bounds on the worst/best-case Resource usage (a.k.a. cost) of ABS programs. The inferred upper bounds have important applications in the fields of program optimization, verification and certification. CostABS is parametric on the cost model, i.e., the type of cost that the user wants to infer (e.g., number of steps, amount of memory allocated, amount of data transmitted, etc.), and it supports different notions of cost such as sequential, parallel, peak, etc.\n Resources  An introduction to time and resource modeling in ABS. Core ABS ABS is a modeling language which combines functional and imperative programming styles to develop high-level executable models. Concurrent object groups execute in parallel and communicate through asynchronous method calls. To intuitively capture internal computation inside a method, we use a simple functional language based on user-defined algebraic data types and functions. Thus, the modeler may abstract from the details of low-level imperative implementations of data structures, and still maintain an overall object-oriented design which is close to the target system.\n "
},
{
	"uri": "http://abs-models.org/publications/",
	"title": "Selected Publications",
	"tags": [],
	"description": "",
	"content": " This page contains selected research papers on the development and usage of the ABS modeling language and analysis tools.\nCase Studies  E. Albert, F. de Boer, R. Hähnle, E. B. Johnsen, R. Schlatte, S. L. Tapia Tarifa, P. Y. H. Wong.\nFormal modeling and analysis of resource management for cloud architectures: an industrial case study using Real-Time ABS.\nService Oriented Computing and Applications 8 (4):323-339, 2014.\nDOI: 10.1007/s11761-013-0148-0. Download a preprint.\n J-C Lin, I. C. Yu, E. B. Johnsen, M-C Lee.\nABS-YARN: A Formal Framework for Modeling Hadoop YARN Clusters.\nProc. 19th Intl. Conf. on Fundamental Approaches to Software Engineering (FASE 2016). LNCS 9633. Springer, 2016.\nDOI: 10.1007/978-3-662-49665-7_4. Download a preprint.\n  Language Development  E. B. Johnsen, R. Hähnle, J. Schäfer, R. Schlatte, and M. Steffen.\nABS: A Core Language for Abstract Behavioral Specification.\nIn Proc. 9th Intl. Symp. on Formal Methods for Components and Objects (FMCO 2010), LNCS 6957. Springer , 2011.\nDOI: 10.1007/978-3-642-25271-6_8. Download a preprint.\n E. B. Johnsen, R. Schlatte, and S. L. Tapia Tarifa.\nIntegrating Deployment Architecture and Resource Consumption in Timed Object-Oriented Models.\nJournal of Logical and Algebraic Methods in Programming 84(1): 67-91, 2015.\nDOI: 10.1016/j.jlamp.2014.07.001. Download a preprint.\n  Deductive Verification  C. C. Din, R. Bubel and R. Hähnle.\nKeY-ABS: A Deductive Verification Tool for the Concurrent Modelling Language ABS.\nIn Proc. 25th Intl. Conf. on Automated Deduction (CADE 2015), LNCS 9195. Springer, 2015.\nDOI:10.1007/978-3-319-21401-6_35. Download a preprint.\n C. C. Din, S. L. Tapia Tarifa, R. Hähnle and E. B. Johnsen.\nHistory-Based Specification and Verification of Scalable Concurrent and Distributed Systems.\nIn Proc. 17th Intl. Conf. on Formal Engineering Method (ICFEM 2015), LNCS 9407. Springer, 2015.\nDOI: 10.1007/978-3-319-25423-4_14. Download a preprint.\n  Cost Analysis  E. Albert, P. Arenas, A. Flores-Montoya, S. Genaim, M. Gómez-Zamalloa, E. Martin-Martin, G. Puebla, and G. Román-Díez.\nSACO: Static Analyzer for Concurrent Objects.\nIn Proc. 20th Intl. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS). LNCS 8413, Springer, 2014.\nDOI: 10.1007/978-3-642-54862-8_46. Download a preprint.  Deadlock Analysis  E. Giachino, C. Laneve, and M. Lienhardt.\nA Framework for Deadlock Detection in ABS.\nJournal of Software and Systems Modeling, to appear, 2015.\nDOI: 10.1007/s10270-014-0444-y. Download a preprint.  Code Generation from ABS  B. Nobakht and F. S. de Boer.\nProgramming with Actors in Java 8.\nIn Proc. of the 6th Intl. Symposium on Leveraging Applications of Formal Methods, Verification and Validation (ISoLA’14). LNCS 8803. Springer, 2014.\nDOI: 10.1007/978-3-662-45231-8_4. Download a preprint.  Model-based Deployment and Monitoring  R. Hähnle and E. B. Johnsen.\nDesigning Resource-Aware Cloud Applications.\nIEEE Computer 48 (6), 2015.\nDOI: 10.1109/MC.2015.172. Download a preprint.\n B. Nobakht, S. de Gouw and F.S. de Boer.\nFormal Verification of Service Level Agreements Through Distributed Monitoring.\nIn Proc. 4th European Conf. on Service Oriented and Cloud Computing (ESOCC 2015). LNCS 9306, Springer, 2015.\nDOI: 10.1007/978-3-319-24072-5_9. Download a preprint.\n  "
},
{
	"uri": "http://abs-models.org/contact/",
	"title": "Contact",
	"tags": [],
	"description": "",
	"content": "Slack channel, mailing list, Github repo\n"
},
{
	"uri": "http://abs-models.org/acknowledgments/",
	"title": "Acknowledgments",
	"tags": [],
	"description": "",
	"content": " Projects The development of the ABS language and tools has been supported by a number of European FP7 and H2020 research projects.\n HATS: Highly Adaptive and Trustworthy Software using Formal Methods\n Envisage: Engineering Virtualized Services\n HyVar: Scalable Hybrid Variability\n  Contributors The following people have contributed to the ABS language and tools so far:\n Elvira Albert Ade Azurat Nikolaos Bezirgiannis Joakim Bjørk Frank de Boer Richard Bubel Dave Clarke Jesús Correas Ferruccio Damiani Crystal Chang Din Antonio Flores-Montoya Abel Garcia Samir Genaim Elena Giachino Miguel Gómez-Zamalloa Georg Göri Stijn de Gouw Reiner Hähnle Einar Broch Johnsen Eduard Kamburjan Ivan Lanese Cosimo Laneve Michael Lienhardt Kelly Lin Enrique Martin-Martin Jacopo Mauro Radu Muschevici Behrooz Nobakht Olaf Owe Björn Petersen Germán Puebla Violet Ka I Pun Guillermo Román-Díez Ina Schaefer Rudi Schlatte Vlad Serbanescu Faiza Shehzad Oliver Stahl Martin Steffen Volker Stolz S. Lizeth Tapia Tarifa Lars Tveito Peter Y.H. Wong Ingrid Chieh Yu Miky Zamalloa Gianluigi Zavatarro  "
},
{
	"uri": "http://abs-models.org/tutorials/costabs/",
	"title": "CostABS",
	"tags": [],
	"description": "",
	"content": "CostABS is a a static analyzer for automatically inferring upper/lower bounds on the worst/best-case Resource usage (a.k.a. cost) of ABS programs. The inferred upper bounds have important applications in the fields of program optimization, verification and certification. CostABS is parametric on the cost model, i.e., the type of cost that the user wants to infer (e.g., number of steps, amount of memory allocated, amount of data transmitted, etc.), and it supports different notions of cost such as sequential, parallel, peak, etc.\nIn this tutorial, we overview the different features of CostABS by example. All examples are linked to the collaboratory where you can directly replay the steps described in the tutorial.\nGeneral Overview: Resource Analysis In what follows we present how to use EasyInterface with the different analyses that CostABS is able to perform with some examples.\nWe first show how to start to use CostABS within the ABS collaboratory. For this, we must first select the analysis in the top pull-down menu, and, for executing the analysis, we click on Run. The Clear button (top right) removes all previous results.\nThe parameters of the selected analysis can be configured by clicking on the ~Settings~ button located in the top-left corner of the EasyInterface page. The results of the selected analysis are presented in the console at the bottom of the screen. This can be done by means of graphs, text messages, markers, highlighters in the code, and interactions among them. In the following, we describe the use of CostABS by analyzing several examples.\nBasic Resource Analysis Let us start by performing the basic resource analysis computed by CostABS and described in this paper. To do it, open the file VendingMachine_init.abs, which contains the following code:\nmodule VendingMachine_init; interface VendingMachine { Unit insertCoin(); Unit insertCoins( Int nCoins ); Int retrieveCoins(); } interface PrettyPrinter { Unit showIncome( Int nCoins ); Unit showCoin(); } class IVendingMachine( Int coins, PrettyPrinter out ) implements VendingMachine{ Unit insertCoin(){ coins = coins + 1; } Unit insertCoins( Int nCoins ){ while( nCoins \u0026gt; 0 ){ nCoins = nCoins - 1; Fut\u0026lt;Unit\u0026gt; f = this ! insertCoin(); await f?; } } [coins \u0026lt; max(coins)] Int retrieveCoins(){ Int total = 0; while( coins \u0026gt; 0 ){ coins = coins - 1; Fut\u0026lt;Unit\u0026gt; f = out ! showCoin(); //await f?; total = total + 1; } return total; } } class IPrettyPrinter implements PrettyPrinter{ Unit showIncome( Int nCoins ){ /*Show something*/ } Unit showCoin(){ /*Show something*/ } } class IMain { Unit main( Int n ){ PrettyPrinter o = new IPrettyPrinter(); VendingMachine v = new IVendingMachine( 0, o ); v ! insertCoins(n); Fut\u0026lt;Int\u0026gt; f = v ! retrieveCoins(); await f?; Int total = f.get; o ! showIncome( total ); } }  By selecting Resource Analysis and clicking on Settings a pop-up window appears and shows the configuration that allows us to set up the parameters for the analysis. The following parameters are available:\n Cost model The cost model indicates the type of resource that we are interested in measuring. The user can select among the following cost metrics: termination (only termination is proved), steps (counts the number of executed instructions), objects (counts the number of executed new instructions), tasks (counts the number of asynchronous calls to methods), memory (measures the size of the created data structures), data transmitted (measures the amount of data transmitted among the distributed objects), user-defined model (allows to write annotations in the code of the form [cost == expr] and the analysis accumulates the cost specified by the user in expr every time this program point is visited).   Cost centers This option allows us to decide whether we want to obtain the cost per cost center (i.e., for each of the abstract objects inferred by the analysis) or a monolithic expression that accumulates the whole computation in the distributed system. The value no refers to the latter case. If we want to separate the cost per cost center, we have again two possibilities. The option class shows the cost of all objects of the same class together, while objectindicates the cost attributed to each abstract object.   Asymptotic bounds Upper bounds can be displayed in asymptotic or non-asymptotic form. The former one is obtained by removing all constants and subsumed expressions from the non-asymptotic cost, only showing the complexity order.   Symbolic or numeric Next, if the cost model is memory or objects, the upper bounds can be shown either symbolically, in terms of symbolic sizes (we use size(A) to refer to the size of an object of type A), or numeric, by assigning a predefined measure to them.   Debug sets the verbosity of the output (the higher the number, the more verbose the output).   Rely Guarantee performs the resource analysis taking into account the possible interleavings in the tasks execution (as described in this paper).   Peak Cost Analysis computes the peak cost analysis for all objects which are identified (see this paper).   Parallel Cost Analysis computes the parallel cost analysis of the program (see this paper).   Non-cumulative Cost Analysis computes the non-cumulative cost of the program (see this paper).   Backend of the Analysis SACO uses PUBS or CoFloCo as backend to solve the cost equations (see this technical report).   Conditional Upper Bounds computes a set of conditional upper bounds (UBs) according to some conditions on the input parameters (see this technical report).   Timed Cost Analysis computes the cost analysis in time (see this technical report).  Let us analyze the program VendingMachine_init.abs with the default values, except for the Asymptotic bounds parameter that must be set to yes. Click on Refresh Outline and select the entry method (method main of class IMain) in the Outline (the region on the right of the page). Then click on Run to perform the analysis. The result should be shown in the console as follows:\nMethod IMain.main terminates?: YES UB for 'IMain.main'(this,n,max(coins)) = nat(n)+nat(max(coins))  It can be seen in the resource analysis results given by CostABS that the upper bound is linear and it is a function on n (the input parameter of ~main~) and on the maximum value that the field coins can take, denoted ~max(coins)~. Variable n is wrapped by function nat previously defined to avoid negative costs. The upper bound is shown in the console view and also at the method’s header when the mouse passes over the marker in line 48 in the program.\nNow, let us analyze the main method of the file VendingMachine.abs, which contains the following code:\nmodule VendingMachine; interface VendingMachine { Unit insertCoin(); Unit insertCoins( Int nCoins ); Int retrieveCoins(); } interface PrettyPrinter { Unit showIncome( Int nCoins ); Unit showCoin(); } interface Main{ Unit main( Int n ); } class IVendingMachine( Int coins, PrettyPrinter out ) implements VendingMachine{ Unit insertCoin(){ coins = coins + 1; } Unit insertCoins( Int nCoins ){ while( nCoins \u0026gt; 0 ){ nCoins = nCoins - 1; Fut\u0026lt;Unit\u0026gt; f = this ! insertCoin(); await f?; } } Int retrieveCoins(){ Int result = 0; while( coins \u0026gt; 0 ){ coins = coins - 1; Fut\u0026lt;Unit\u0026gt; f = out ! showCoin(); await f?; result = result + 1; } return result; } } class IPrettyPrinter implements PrettyPrinter{ Unit showIncome( Int nCoins ){ /*Show something*/ } Unit showCoin(){ /*Show something*/ } } class IMain implements Main{ Unit main( Int n ){ PrettyPrinter o = new IPrettyPrinter(); VendingMachine v = new IVendingMachine( 0, o ); v ! insertCoins(n); Fut\u0026lt;Int\u0026gt; f = v ! retrieveCoins(); await f?; Int result = f.get; o ! showIncome( result ); } }  This file is just like the previous example, but includes the await instruction at line 37 that was commented out in the previous program. Analyze this program with the same configuration as before: default setting values, except for the asymptotic bounds parameter set to yes. Click on ~Refresh Outline~ and select the entry method (method main of class IMain) in the outline. Then click on Run to perform the analysis. The results will be shown like this:\nMethod IMain.main terminates?: UNKOWN UB for 'IMain.main'(this,n) = nat(n)+c(failed(no_rf,[scc=7,cr=entrywhile_1/4]))  The analyzer shows, by using a warning marker (see line 41), that the resource analysis cannot infer an upper bound nor guarantee the termination of the program.\nRely-Guarantee Resource Analysis NOTE: this analysis is not currently available.\n Let us now perform the rely-guarantee resource analysis, described in this paper, on the main method of the VendingMachine.abs file. To do so, we set the option Rely Guarantee to yes and the Cost Model to termination.\nAfter applying the analysis, it can be seen on the default console that CostABS proves that all methods of the program terminate. Let us now slightly modify the example to make method insertCoins non-terminating by removing line 35 with the instruction coins = coins – 1. The analysis information is displayed as follows. For each strongly connected component(SCC) (SCC-while loops and recursive methods are basically the SCCs in a program), the analysis places a marker in the entry line to the SCC. If the SCC is terminating (eg. line 25), by clicking on the marker, the lines that compose this SCC are highlighted in yellow. On the other hand, if the SCC is non-terminating (line 34), by clicking on the marker, CostABS highlights the lines of the SCC in blue. Besides the markers, the list of all SCCs of the program and their computed termination results are printed by CostABS on the console.\nAt this point, let us perform the rely guarantee resource analysis to infer the cost of the program. Restore the original code of line 35, click on ~Settings~ and select the Steps cost model with the option Rely guarantee set to yes. Then click on Run to perform the analysis.\nThe resulting upper bound obtained is a function in terms on n (the input parameter of main) and in terms of the maximum value that field coins can take, denoted max(coins). We can observe that the cost of main is linear with respect to both. In addition, CostABS shows a marker to the left of each method header to display their corresponding upper bounds.\nLoad Balance At this point, let us use the resource analysis to study the load balance of the program Performance.abs, which contains the following code:\nmodule Parallel; import * from ABS.StdLib; interface I { Unit m (Int n); Unit p (Int n, I x); Unit m2 (Int n); Unit q (); } class C implements I{ Unit m (Int n) { I a = new C(); while (n \u0026gt; 0) { a!p(n, a); n = n - 1; } } Unit mthis (Int n) { I a = new C(); while (n \u0026gt; 0) { a!p(n, this); n = n - 1; } } Unit p (Int n, I x) { while (n \u0026gt; 0) { x!q(); n = n - 1; } } Unit m2 (Int n) { while (n \u0026gt; 0) { I a = new C (); a!p(n, a); n = n - 1; } } Unit q () { skip; } }  As the concurrency unit of ABS is the object, this analysis uses the cost centers to assign the cost of each execution step to the object where the step is performed. We start by applying the Resource Analysis and setting the option Cost Centers to object in the settings. Then click on Refresh Outline and select the method C.m on the right region of the page. Finally, click on Run to perform the analysis. In the console, we see the following output:\nUB Object Sensitive for C.m(this,n): 6*c([C.m])+nat(n)* (2*c([C.m])+5*c([C.m])+3*c([1,C.m])+nat(n)* (2*c([1,C.m])+5*c([1,C.m])+2*c([1,C.m]))+2*c([1,C.m])+c([1,C.m]))+2*c([C.m])+c([C.m])+c([1,C.m]) UB for cobox ([13,12],C): 1+nat(n)* (6+9*nat(n)) UB for cobox ([12],C.m): 9+7*nat(n)  CostABS returns the cost centers in the program, one cost center labelled with ~[12]~ which corresponds to the object that executes C.m and another one labelled with [13,12], which abstracts the object created at line 13. The labels of the nodes contain the program lines where the corresponding object is created. That is, the node labeled as [13,12] corresponds to the C object, created at line 13 while executing the main method, the node identified by line 12. In addition, CostABS shows a graph with both nodes in the Console Graph view at the bottom of the screen. By clicking on the node ~[12]~, CostABS shows a dialog box with the upper bound on the number of steps performed by this node. Similarly, by clicking on the node [13,12], it shows the number of steps that can be executed by the object identified with ~[13,12]~.\nWe can observe that the node [12] performs a number of steps that is bounded by a linear function on the input parameter n, while in the node [13,12] the number of steps is bounded by a quadratic function on n. If we analyze method C.mthis, the cost is distributed in a different way. In this case, both nodes [20] and [21,20] have a quadratic upper bound on the number of steps performed by each node. The difference between both methods is that the call x!q() at line 30 is performed in object [13,12] in the former case, and in object [20] in the latter.\nWe can obtain the number of instances of each object we can have in each node. Select C.m2 and unselect the previously selected methods on the outline on the right of the page, and perform the Resource Analysis, setting the options ~Cost Model~ to Objects and Cost Centers to Object. It can be seen in the output of CostABS that the number of instances of the object identified by ~[37,35]~ is bounded by n (the input argument of method m2). Finally, we can apply the resource analysis to C.m2 selecting Cost Model to Steps to obtain the results of the analysis for this method regarding the number of steps.\nTransmission Data Sizes Now, let us perform the transmission data size analysis to the following code:\nmodule DemoTraffic; import * from ABS.StdLib; interface II { Unit work (Int n, List\u0026lt;Int\u0026gt; l); } interface IS { Int process (List\u0026lt;Int\u0026gt; l); } class Master (IS s) implements II { Unit work (Int n, List\u0026lt;Int\u0026gt; l){ while (n\u0026gt;0) { l = Cons(1,l); Fut\u0026lt;Int\u0026gt; q = s!process(l); q.get; n = n - 1; } } } class Slave () implements IS{ Int process (List\u0026lt;Int\u0026gt; l) {return 1;} } class IMain { Unit main (List\u0026lt;Int\u0026gt; l, Int n) { IS s = new Slave(); II m = new Master(s); m!work(n,l); } }  Open the file DataTransmitted.abs. To analyze this file with the transmission data size analysis, select the analysis Resource Analysis (SACO) and set the option Cost Model to Traffic. Then refresh the outline and apply the analysis to the method IMain.main.\nWhen the analysis is applied, the console will show the upper bound expressions for all possible pairs of objects identified by the analysis:\nUB Object Sensitive for IMain.main(this,l,n): c(o([IMain.main],[2,IMain.main],Master.work))* (1+c(i)+nat(l))+c(o([2,IMain.main],[IMain.main],Master.work))* (1+c(i))+c(o([IMain.main],[2,IMain.main],Master.init))* (1+c(i))+c(o([2,IMain.main],[IMain.main],Master.init))*c(i)+c(o([IMain.main],[1,IMain.main],Slave.init))*c(i)+c(o([1,IMain.main],[IMain.main],Slave.init))*c(i)+nat(n)* (c(o([2,IMain.main],[1,IMain.main],Slave.process))* (c(i)+nat(l+2*n))+c(o([1,IMain.main],[2,IMain.main],Slave.process))* (1+c(i))) UB for interactions between ([31],[32,31]): c(i) UB for interactions between ([31],[33,31]): 2+nat(l)+2*c(i) UB for interactions between ([33,31],[32,31]): nat(n)* (c(i)+nat(l+2*n)) UB for interactions between ([32,31],[31]): c(i) UB for interactions between ([33,31],[31]): 1+2*c(i) UB for interactions between ([32,31],[33,31]): nat(n)* (1+c(i))  For example, the last line of the console output is the upper bound of the size of the data transmitted from the node [32,31] to the node [33,31], that are the Slave and Master objects created at line 32 and line 33, respectively. We can observe that this upper bound linearly depends on the input parameter n, which is the number of times the method process in the ~Slave~ object is invoked. On the other hand, the data transmitted from the ~Master~ object [33,31] to the Slave object [32,31] is different, as the invocation contains the list l which is passed as argument to the method ~process~. In this case, the upper bound is a quadratic function on the parameter n, as the list passed as argument grows at each iteration of the loop at line 16, and this loop iterates n times.\nIn addition to the console information, the graph in output tab Console Graph shows the objects creation. By clicking on a node in the graph, a message outputs the UBs (upper bounds) for all transmissions data sizes that the selected object can perform and the objects involved in such transmissions. For example, by clicking on the node [32,31], which corresponds to the Master object, we can see the upper bounds on the data transmitted (incoming and outgoing transmissions) from this object. As before, the labels of the nodes contain the program lines where the corresponding object is created. For instance, the node labeled as [32,31]~ corresponds to the ~Master object, created at line 32 while executing the main method, the object identified by line 31. In such upper bounds, the cost expression c(i) represents the cost of establishing the communication.\nNon-Cumulative Cost We can illustrate the analysis for computing the non-cumulative cost with the file Noncumulative.abs, which contains the following code:\nmodule Noncumulative; import * from ABS.StdLib; class IMain { Unit main (Int s, Int n) { [x == acquire(10)] Int i= 0; [r == acquire(100)] i = 0; [r == acquire(s)] i = 1; [r == release()] i = 2; [y == acquire(n)] i = 3; [x == release()] i = 4; } }  In Settings, restore the default values and set the option noncumulative_cost to yes. Then refresh the outline and select the method IMain.main. The results obtained after clicking Run show that we have two sets of program points that can lead to the maximum on the number of resources acquired, as well as their corresponding upper bound expressions. The set [L6,L8,L10] corresponds to the acquireinstructions at lines 6, 8 and 10 of the program. With this set of acquire instructions, we obtain an upper bound of the number of resources that linearly depends on the input parameter s because of the acquire at line 10. The set [L6,L8,L14] can also lead to the maximum number of resources acquired, if the actual value of the input parameter n is larger than s.\nPeak Cost Analysis Let us continue by performing the peak cost analysis to the program VendingMachine_init.abs. Similarly to other analyses, we first select the entry method (method main in class IMain) in the outline view and start the Resource Analysis (SACO) with default options, with the exception of the option Peak Cost, which must be set to yes. After clicking Run, the peak cost analysis outputs in the console.\nClosure time 2 ms. Direct mhp time 0 ms. Indirect mhp time 24 ms. Configurations found for queue [49,48] -- IPrettyPrinter.showIncome,IPrettyPrinter.showCoin -- IPrettyPrinter.init UBs for the configurations of queue [49,48] -- UB_k for [49,48]-[IPrettyPrinter.showIncome,IPrettyPrinter.showCoin]): 2+2*nat(max(coins)-1) -- UB_k for [49,48]-[IPrettyPrinter.init]): 0 Configurations found for queue [50,48] -- IVendingMachine.insertCoins,IVendingMachine.retrieveCoins,IVendingMachine.insertCoin -- IVendingMachine.init UBs for the configurations of queue [50,48] -- UB_k for [50,48]-[IVendingMachine.insertCoins,IVendingMachine.retrieveCoins,IVendingMachine.insertCoin]): 13+14*nat(n)+13*nat(max(coins)-1) -- UB_k for [50,48]-[IVendingMachine.init]): 0  For each identified ABS object, all possible queue configurations are shown. A queue configuration is the set of tasks that can be in the task queue simultaneously. For each queue configuration, the tasks involved in the configuration are shown. In addition, the total cost associated with the configuration is displayed as well.\nThe analysis of the program VendingMachine_init.abs shows that there are two possible queue configurations for each object identified in the program. For example, for the object [49,48] one of the configurations contains tasks for methods showIncome and showCoin, and the number of steps executed by those tasks linearly depends on the value of the field coins.\nAs before, the output tab Console Graph also shows a graph where the labels of the nodes contain the program lines where the corresponding object is created. For instance, the node labeled as [49,48] corresponds to the PrettyPrinter object, created at line 49 while executing the main method which starts at line 48. By clicking on a node, the queue configurations that have been identified and their costs are shown in a message.\nParallel Cost Let us perform the parallel cost analysis described in this paper. To do so, we open the file Parallel.abs, which contains the following code:\nmodule Parallel; import * from ABS.StdLib; interface IX { Unit p (IY y); } interface IY { Unit q (); Unit s (); } class X implements IX { Unit p (IY y) { skip; y!s(); Int method_end = 0; } } class Y implements IY { Unit q () { Int method_end = 0; } Unit s () { Int method_end = 0; } } class IMain { Unit main () { IX x = new X (); IY y = new Y (); x!p(y); skip; y!q(); Int method_end = 0; } }  Select the entry method IMain.main in the outline and apply the Resource Analysis by restoring the default values and setting the option Parallel Cost to yes. The analysis results show the computed upper bound expressions obtained for all paths identified in the DFG (distributed flow graph) of the program. In addition, the result shows the number of nodes and edges of the computed DFG.\nClosure time 1 ms. Direct mhp time 0 ms. Indirect mhp time 3 ms. DFG Number of Nodes: 11 DFG Number of Edges: 12 DFG Number of Exit nodes: 4 Number of Paths found: 16 The Parallel Cost for IMain.main(this) is the maximum of the expressions (4): UB Expression: 10 UB Expression: 14 UB Expression: 13 UB Expression: 9  "
},
{
	"uri": "http://abs-models.org/",
	"title": "The ABS Language",
	"tags": [],
	"description": "",
	"content": " The ABS Language ABS is a language for Abstract Behavioral Specification, which combines implementation-level specifications with verifiability, high-level design with executablity, and formal semantics with practical usability. ABS is a concurrent, object-oriented, modeling language that features functional data-types.\n ABS is designed to develop executable models with an object-oriented program flow ABS targets distributed and concurrent systems by means of concurrent object groups and asynchronous method calls ABS supports model variability based on delta-oriented specifications ABS supports deployment modelling based on high-level deployment models ABS supports a range of techniques for model exploration and analysis, based on formal semantics  Overview\nGetting Started\nTutorials\nPublications\nContact\n"
},
{
	"uri": "http://abs-models.org/tutorials/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": "An introduction to time and resource modeling in ABS.\nCore ABS ABS is a modeling language which combines functional and imperative programming styles to develop high-level executable models. Concurrent object groups execute in parallel and communicate through asynchronous method calls. To intuitively capture internal computation inside a method, we use a simple functional language based on user-defined algebraic data types and functions. Thus, the modeler may abstract from the details of low-level imperative implementations of data structures, and still maintain an overall object-oriented design which is close to the target system. At a high level of abstraction, concurrent object groups typically consist of a single concurrent object; other objects may be introduced into a group as required to give some of the algebraic data structures an explicit imperative representation in the model. In this tutorial, we aim at high-level models and the groups will consist of single concurrent objects. The functional sublanguage of ABS consists of a library of algebraic data types such as the empty type Unit, booleans Bool, integers Int, parametric data types such as sets Set\u0026lt;A\u0026gt; and maps Map\u0026lt;A\u0026gt; (given a value for the type variable A), and (parametric) functions over values of these data types. For example, we can define polymorphic sets using a type variable A and two constructors ~EmptySet~ and Insert, and a function contains which checks whether an element el is in a set ss recursively by pattern matching over ~ss~:\ndata Set\u0026lt;A\u0026gt; = EmptySet | Insert(A, Set\u0026lt;A\u0026gt;); def Bool contains\u0026lt;A\u0026gt;(Set\u0026lt;A\u0026gt; ss, A el) = case ss { EmptySet =\u0026gt; False ; Insert(el, _) =\u0026gt; True; Insert(_, xs) =\u0026gt; contains(xs, el); };  Here, the cases p=\u0026gt;exp are evaluated in the listed order, underscore works as a wild card in the pattern p, and variables in p are bound in the expression exp. The imperative sublanguage of ABS addresses concurrency, communication, and synchronization at the concurrent object level in the system design, and defines interfaces and methods with a Java-like syntax. ABS objects are active; i.e., their run method, if defined, gets called upon creation. Statements are standard for sequential composition s1;s2, assignments x=rhs, and for the skip, if, while, and return~ constructs. The statement ~suspend unconditionally suspends the execution of the active process of an object by adding this process to the queue, from which an enabled process is then selected for execution. In await g, the guard g controls the suspension of the active process and consists of Boolean conditions b and return tests x? (see below). Just like functional expressions e, guards g are side-effect free. If g evaluates to False, the active process is suspended, i.e., added to the queue, and some other process from the queue may execute. Expressions rhs include the creation of an object group new C(e), object creation in the group of the creator new local C(e), method calls o!m(e) and o.m(e), future dereferencing x.get, and pure expressions e apply functions from the functional sublanguage to state variables. Communication and synchronization are decoupled in ABS. Communication is based on asynchronous method calls, denoted by assignments f=o!m(e) to future variables f. Here, o is an object expression and e are (data value or object) expressions providing actual parameter values for the method invocation. (Local calls are written ~this!m(e)~.) After calling f=o!m(e), the future variable f refers to the return value of the call and the caller may proceed with its execution without blocking on the method reply. There are two operations on future variables, which control synchronization in ABS. First, the guard await f? suspends the active process unless a return to the call associated with f has arrived, allowing other processes in the object group to execute. Second, the return value is retrieved by the expression f.get, which blocks all execution in the object until the return value is available. The statement sequence x=o!m(e);v=x.get encodes commonly used blocking calls, abbreviated ~v=o.m(e)~ (often referred to as synchronous calls). If the return value of a call is without interest, the call may occur directly as a statement ~o!m(e)~ with no associated future variable. This corresponds to message passing in the sense that there is no synchronization associated with the call.\nReal-Time ABS Real-Time ABS is an extension of ABS which captures the timed behavior of ABS models. An ABS model is a model in Real-Time ABS in which execution takes zero time; thus, standard statements in ABS are assumed to execute in zero time. Timing aspects may be added incrementally to an untimed behavioral model. Our approach extends the distributed concurrent object groups in ABS with an integration of both explicit and implicit time.\nDeadlines The object-oriented perspective on timed behavior is captured by deadlines to method calls. Every method activation in Real-Time ABS has an associated deadline, which decrements with the passage of time. This deadline can be accessed inside the method body with the expression deadline(). Deadlines are soft; i.e., deadline() may become negative but this does not in itself block the execution of the method. By default the deadline associated with a method activation is infinite, so in an untimed model deadlines will never be missed. Other deadlines may be introduced by means of call-site annotations. Real-Time ABS introduces two new data types into the functional sublanguage of ABS: Time, which has the constructor Time(r), and Duration, which has the constructors InfDuration and Duration(r), where r is a value of the type Rat of rational numbers. The accessor functions timeVal and ~durationValue~ return r for time and duration values Time(r) and ~Duration(r)~, respectively. Let o be an object which implements a method ~m~. Below, we define a method n which calls m on o and specifies a deadline for this call, given as an annotation and expressed in terms of its own deadline. Remark that if its own deadline is InfDuration, then the deadline to m will also be unlimited. The function scale(d,r) multiplies a duration d by a rational number r (the definition of scale is straightforward).\nInt n (T x){ [Deadline: scale(deadline(),0.9)] return o.m(x); }  Explicit Time In the explicit time model of Real-Time ABS, the execution time of computations is modeled using duration statements duration(e1,e2) with best- and worst-case execution times e1 and e2. These statements are inserted into the model, and capture execution time which does not depend on the system’s deployment architecture. Let f be a function defined in the functional sublanguage of ABS, which recurses through some data structure x~ of type ~T, and let size(x) be a measure of the size of this data structure ~x~. Consider a method m which takes as input such a value x and returns the result of applying f to x. Let us assume that the time needed for this computation depends on the size of x~; e.g., the computation time is between a duration ~0.5*size(x) and a duration 4*size(x). An interface I~ which provides the method ~m and a class C which implements I, including the execution time for m using the explicit time model, are specified as follows:\ninterface I { Int m(T x) } class C implements I { Int m (T x){ duration(0.5*size(x), 4*size(x)); return f(x); } }  Implicit Time In the implicit time model of Real-Time ABS, the execution time is not specified explicitly in terms of durations, but rather observed on the executing model. This is done by comparing clock values from a global clock, which can be read by an expression now() of type Time. We specify an interface J with a method p which, given a value of type T, returns a value of type Duration, and implement p in a class D such that p~ measures the time needed to call the method ~m above, as follows:\ninterface J { Duration p (T x) } class D implements J (I o) { Duration p (T x){ Time start; Int y; start = now(); y=o.m(x); return timeDifference(now(),start); } }  Observe that by using the implicit time model, no assumptions about execution times are specified in the model above. The execution time depends on how quickly the method call is effectuated by the called object. The execution time is simply measured during execution by comparing the time before and after making the call. As a consequence, the time needed to execute a statement with the implicit time model depends on the capacity of the chosen deployment architecture and on synchronization with (slower) objects.\nModeling Deployment Architectures in ABS Deployment Components A deployment component in Real-Time ABS captures the execution capacity associated with a number of concurrent object groups. Deployment components are first-class citizens in Real-Time ABS, and provide a given amount of resources which are shared by their allocated objects. Deployment components may be dynamically created depending on the control flow of the ABS model or statically created in the main block of the model. We assume a deployment component environment with unlimited resources, to which the root object of a model is allocated. When objects are created, they are by default allocated to the same deployment component as their creator, but they may also be allocated to a different component. Thus, a model without explicit deployment components runs in environment, which does not impose any restrictions on the execution capacity of the model. A model may be extended with other deployment components with different processing capacities. Given the interfaces I and J and classes C and D defined in above, we can for example specify a deployment architecture in which two C objects are deployed on different deployment components server1 and server2, and interact with the D objects deployed on a deployment component ~clientServer~. Deployment components in Real-Time ABS have the type DC and are instances of the class DeploymentComponent. This class takes as parameters a name, given as a string, and a set of restrictions on resources. The name is mainly used for monitoring purposes. Here we focus on resources reflecting the components’ processing capacity, which are specified by the constructor CPUCapacity(r), where r represents the amount of abstract processing resources available between observable points in time. Below, we create three deployment components Server1, Server2, and ClientServer, with the processing capacities 6, 3, and unlimited (i.e., ClientServer has no resource restrictions). The local variables server1, server2, and ~clientServer~ refer to these three deployment components, respectively. Objects are explicitly allocated to the servers by annotations; below, ~object1~ is allocated to Server1, etc.\n{ // This main block initializes a static deployment architecture: DC server1 = new DeploymentComponent(\u0026quot;Server1\u0026quot;,set[CPUCapacity(6)]); DC server2 = new DeploymentComponent(\u0026quot;Server2\u0026quot;,set[CPUCapacity(3)]); DC clientServer = new DeploymentComponent(\u0026quot;ClientServer\u0026quot;, EmptySet); [DC: server1] I object1 = new cog C; [DC: server2] I object2 = new cog C; [DC: clientServer] J client1monitor = new cog D(object1); [DC: clientServer] J client2monitor = new cog D(object2); }   The figure depicts this deployment architecture and the artefacts introduced into the modeling language. Since all objects are allocated to a deployment component (which is environment unless overridden by an annotation), we let the expression thisDC() evaluate to the deployment component of an object. For convenience, a call to the method total(\u0026quot;CPU\u0026quot;) of a deployment component returns its total amount of allocated CPU resources.\nResource Costs The available resource capacity of a deployment component determines how much computation may occur in the objects allocated to that component. Objects allocated to the component compete for the shared resources in order to execute, and they may execute until the component runs out of resources or they are otherwise blocked. For the case of CPU resources, the resources of the component define its processing capacity between observable (discrete) points in time, after which the resources are renewed.\nCost models The cost of executing statements in the ABS model is determined by a default value which is set as a compiler option (e.g., defaultcost=10). However, the default cost does not discriminate between statements and we may want to introduce a more refined cost model. For example, if e is a complex expression, then the statement x=e should have a significantly higher cost than skip in a realistic model. For this reason, more fine-grained costs can be inserted into Real-Time ABS models by means of annotations. For example, let us assume that the cost of computing the function f(x) defined in the section on Real-Time ABS may be given as a function g which depends on the size of the input value x. In the context of deployment components, we may redefine the implementation of interface I above to be resource-sensitive instead of having a predefined duration as in the explicit time model. The resulting class C2 can be defined as follows:\nclass C2 implements I { Int m (T x){ [Cost: g(size(x))] return f(x); } }  It is the responsibility of the modeler to specify an appropriate cost model. A behavioral model with default costs may be gradually refined to provide more realistic resource-sensitive behavior. For the computation of the cost functions such as g in our example above, the modeler may be assisted by the COSTABS tool, which computes a worst-case approximation of the cost for f in terms of the input value x based on static analysis techniques, when given the ABS definition of the expression f. However, the modeler may also want to capture resource consumption at a more abstract level during the early stages of system design, for example to make resource limitations explicit before a further refinement of a behavioral model. Therefore, cost annotations may be used by the modeler to abstractly represent the cost of some computation which remains to be fully specified. For example, the class C3 below represents a draft version of our method m in which the worst-case cost of the computation is specified although the function f has yet to be introduced:\nclass C3 implements I { Int m (T x){ [Cost: size(x)*size(x)] return 0; } }  "
},
{
	"uri": "http://abs-models.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://abs-models.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]