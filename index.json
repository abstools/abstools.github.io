[
{
	"uri": "https://abs-models.org/getting_started/local-install/",
	"title": "Installing Command-Line Tools",
	"tags": [],
	"description": "",
	"content": " Many of the tools can be run from the command line. This chapter describes how to run various tools on a local machine.\nInstalling the ABS Compiler To install the ABS compiler, install the Java 8 JDK and Erlang (version 21 or higher). Then, clone the git repository and build the compiler:\ngit clone https://github.com/abstools/abstools.git cd abstools ./gradlew assemble  After a successful build, there is an absc shell script in the abstools/frontend/bin/bash/ directory that invokes the ABS compiler. For Windows, there is abstools/frontend/bin/win/absc.bat. After adding that directory to your path environment variable, you can invoke absc on one or more abs source files with a command like absc -erlang model.abs.\nInstalling KeY-ABS For a local installation of the KeY-ABS theorem prover, install Java 8. Then, download KeY-ABS from http://i12www.ira.uka.de/key/key-abs/key-abs.zip. Unzipping that downloaded file and double-clicking on the key.jar file should start KeY-ABS. To start from the command line, use:\njava -jar key.jar  "
},
{
	"uri": "https://abs-models.org/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": " DESIGN PRINCIPLES OF ABS ABS targets the modeling of software systems that are concurrent, distributed, object-oriented, built from components, and highly reusable. To achieve the latter, we follow the arguably most successful software reuse methodology in practice: software product families or software product lines [35], see also the Product Line Hall of Fame. ABS supports the modeling of variability in terms of feature models as a first-class language concept. ABS thus provides language-based support for product line engineering (PLE).\nAs an abstract language ABS is well suited to model software that is supposed to be deployed in a virtualized environment. To close the gap between design and deployment it is necessary to represent low-level concepts such as system time, memory, latency, or scheduling at the level of abstract models. In ABS this is possible via a flexible and pluggable notation called deployment components, covered in detail in [24].\nABS is not merely a modeling notation, but it arrives with an integrated tool set that helps to automate the software engineering process. Tools are useless, however, unless they ensure predictability of results, interoperability, and usability. A fundamental requirement for the first two criteria is a uniform, formal semantics. But interoperability also involves the capability to connect with other notations than ABS. This is ensured by providing numerous language interfaces from and to ABS. These are realized by various import, export, and code generation tools.\nArguably the most important criterion for tools, however, is usability. This tutorial is not the place to embark on a full discussion of what that entails, but it should be indisputable that automation, scalability, and integration are of the utmost importance. To ensure the first two of these qualities, the HATS project adopted as a central principle to develop ABS in tandem with its tool set. This is not merely a historical footnote, but central to an understanding of the trade-offs made in the design of the ABS language. For most specification and programming languages their (automatic) analyzability is considered in hindsight and turns out not to be scalable or even feasible. With ABS, the slogan of design for verifiability that originated in the context of hardware description languages [30], has been systematically applied to a software modeling language. For example, the concurrency model of ABS is designed such that it permits a compositional proof system [3], the reuse principle employed in ABS is chosen in such a way that incremental verification is possible [21], etc. Many formal methods tools focus on analysis, in particular, on verification. Functional verification, model checking, test case generation, and resource estimation are supported by ABS tools as well. Just as important as analytic methods, specifically in a model-based context, are generative ones: ABS is fully executable (albeit in a non-deterministic manner) and supports code generation to Erlang and Maude.\n  ABS language architecture\n  In addition to the simulation tools, a number of analysis and generation tools are available as well. An overview of the ABS tool suite is given in [42].\n"
},
{
	"uri": "https://abs-models.org/documentation/tutorials/language-tutorial/",
	"title": "Language Tutorial",
	"tags": [],
	"description": "This tutorial gives an overview of the ABS language.",
	"content": " This tutorial is partially adapted but needs updating to the newest language and tool features\n1 Installation of the ABS Eclipse Plugin ABS fills a gap in the landscape of software modeling languages. It is situated between architectural, design-oriented, foundational, and implementation-oriented languages [25] For trying out the examples provided in this tutorial you will need the ABS Eclipse plugin. To install it, follow the simple instructions at http://tools. hats-project.eu/eclipseplugin/installation.html. You will need at least Eclipse version 3.6.2 and it is recommended to work with a clean installation. The example project used throughout this tutorial is available as an archive from http://www.hats-project.eu/sites/default/files/TutorialExample.zip. To install, unzip the archive file into a directory /mypath/Account. Then create a new ABS Project and import the directory file contents into Eclipse workspace in the usual way. After opening a few files in the editor you should see a screen similar to the one here:\n2 Design Principles of ABS ABS targets software systems that are concurrent, distributed, object-oriented, built from components, and highly reusable. To achieve the latter, we follow the arguably most successful software reuse methodology in practice: software product families or software product lines [35], see also the Product Line Hall of Fame. To this end, ABS supports the modeling of variability in terms of feature models as a first-class language concept. As shown in Sect. 8, ABS thus provides language-based support for product line engineering (PLE). As an abstract language ABS is well suited to model software that is supposed to be deployed in a virtualized environment. To close the gap between design and deployment it is necessary to represent low-level concepts such as system time, memory, latency, or scheduling at the level of abstract models. In ABS this is possible via a flexible and pluggable notation called deployment components. This goes beyond the present, introductory tutorial, but is covered in detail in the chapter by Johnsen in this volume [24]. ABS is not merely a modeling notation, but it arrives with an integrated tool set that helps to automate the software engineering process. Tools are use- less, however, unless they ensure predictability of results, interoperability, and usability. A fundamental requirement for the first two criteria is a uniform, formal semantics. But interoperability also involves the capability to connect with other notations than ABS. This is ensured by providing numerous language in- terfaces from and to ABS as shown in below. These are realized by various import, export, and code generation tools, several of which are discussed below.\nArguably the most important criterion for tools, however, is usability. This tutorial is not the place to embark on a full discussion of what that entails, but it should be indisputable that automation, scalability, and integration are of the utmost importance. To ensure the first two of these qualities, the HATS project adopted as a central principle to develop ABS in tandem with its tool set. This is not merely a historical footnote, but central to an understanding of the trade-offs made in the design of the ABS language. For most specification and programming languages their (automatic) analyzability is considered in hindsight and turns out not to be scalable or even feasible. With ABS, the slogan of design for verifiability that originated in the context of hardware description languages [30], has been systematically applied to a software modeling language. For example, the concurrency model of ABS is designed such that it permits a compositional proof system [3], the reuse principle employed in ABS is chosen in such a way that incremental verification is possible [21], etc. Many formal methods tools focus on analysis, in particular, on verification. Functional verification, model checking, test case generation, and resource estimation are supported by ABS tools as well. Just as important as analytic methods, specifically in a model-based context, are generative ones: ABS is fully executable (albeit in a non-deterministic manner) and supports code generation to Java, Scala, and Maude. In addition, it is possible to learn ABS models from observed behavior [16]. Regarding integration, the tool set around the ABS language is realized as a set of plugins for the popular Eclipse IDE. These plugins realize the ABS\nModeling Perspective (see Fig. 2) and the ABS Debug Perspective (see Fig. 8), which provide the same functionality as their Java counterparts, that is, parsing, syntax highlighting, parse error location, symbol lookup, compilation, building, runtime configurations, interactive debugging, etc. In addition to these standard development tools, however, a number of analysis and generation tools are available as well. Some of these, for example, Java code generation or type inference are illustrated below. An overview of the ABS tool suite is given in [42].\n3 Architecture of ABS The architecture of ABS has been organized as a stack of clearly separated layers as illustrated in Fig. 4. In the design we strove for\n an attractive, easy-to-learn language with a syntax that is familiar to many developers and to provide maximal separation of concern (orthogonality) among different concepts.  The four bottom layers provide a modern programming language based on a combination of algebraic data types (ADTs), pure functions, and a simple imperative-OO language. The idea is that anyone familiar with either Java and Haskell or with Scala is able to grasp this part of ABS immediately, even though ABS is considerably simpler than any of these languages. The next two layers realize tightly coupled and distributed concurrency, respectively. The concurrency and synchronization constructs are designed in a way to permit a compositional proof theory for functional verification in a program logic [3]. Standard contracts are used for functional specification of sequential programs and behavioral interfaces over sets of histories are used for specifying concurrent programs, see also the paper by Poetzsch-Heffter in this volume [34]. The language layers up to here are often called Core ABS. Above these are orthogonal extensions for product line engineering, deployment components, and runtime components that allow to model mobile code. The latter are not discussed in this volume, but are described in [28]. As mentioned above, ABS is a fully executable language. Nevertheless, abstraction is achieved in a number of ways: first of all, ABS contains only five built-in datatypes\u0026mdash;everything else is user-defined. The rationale is that no premature decision on the properties of datatypes is enforced, which helps to create implementation-independent models. Second, functions on datatypes can be underspecified. The modeler has the alternative to return abstract values or to leave case distinctions incomplete. The latter may result in runtime errors, but is nev- ertheless useful for simulation, test generation or verification scenarios. Third, the scheduling of concurrent tasks as well as the order of queuing messages is non-deterministic. Of course, one might want to give full implementation details at some time. This is possible by refining an ADT into an implemented class or by realizing it in Java via the foreign language interface available in ABS (Sect. 7. Concrete schedulers can be specified via deployment components [24, 32]. Crucially, the abstraction capabilities of ABS allow to specify partial behavior during early design stages, such as feature analysis, without committing to implementation details. This lends support, for example, to rapid prototyping or to the early analysis of consequences of design decisions. ABS has been designed as a compact language. Each layer has no more first-class concepts than are needed to ensure usability (including some syntactic sugar). This does not mean, however, that ABS is a small language: the ABS grammar has considerably more non-terminals than that of Java! The reason is that ABS features several language concepts that are simply not present in Java. In the final analysis, this reflects the ambition of ABS to cover the whole modeling spectrum from feature analysis, deployment mapping, high-level design and down to implementation issues. To show that in spite of this ABS is not unwieldy, but rather easy to use and quite flexible, is the aim of the present tutorial.\n4 The Functional Layer 4.1 Algebraic Data Types The base layer of ABS is a simple language for parametric algebraic data types (ADTs) with a self-explaining syntax. The only predefined datatypes(Foot: There is one more predefined type that is used for synchronization which is explained in Sect. 6.) are Bool,Int, String, Unit and parametric lists as defined below. The type Unit is used as a type for methods without return value and works like Java\u0026rsquo;s void. All other types are user-defined. We assume that the Eclipse plugin is installed (see Sect. 1.3). To create a new ABS file in an existing ABS project, right click on the project in the explorer and choose New|ABS Module. In the input mask that pops up, specify a file name, for example, CustomerData, and click Finish. This creates a new file named CustomerData.abs in the workspace, which can be edited in the usual way. The running example of this tutorial has a banking theme. Let us create some datatypes related to customers. All type and constructor names must be upper-case.\ndata Level = Standard | Silver | Gold; data Customer = Test | Person(Int, Level) | Company(Int);  There are three kind of customers defined by three different type constructors: a test customer, individual customers, and corporate customers. Individual customers are identified by a personal id and possess a status level while corporate customers are identified by their vat number. We can make this more explicit and, at the same, automatically create selector functions for the arguments of each type constructor by the following alternative definition:\ndata Customer = Test | Person(Int pid, Level) | Company(Int vat);  Assume now that we want to define lists of customers. For this we can use the following built-in parametric list type, which provides a convenient concrete syntax for lists:\ndata List\u0026lt;T\u0026gt; = Nil | Cons(T, List\u0026lt;T\u0026gt;); List\u0026lt;Int\u0026gt; l = [1,2,3];  The definition of parametric lists demonstrates that type definitions may be recursive. Let us instantiate parametric lists with Customer and, at the same time, create a type synonym:\ntype CustomerList = List\u0026lt;Customer\u0026gt;;  Type synonyms do not add new types or functionality, but can greatly en- hance readability.\n4.2 Functions The functional layer of ABS consists of a pure first-order functional language with definitions by case distinction and pattern matching. All function names must be lower-case. Let us begin by defining a function that computes the length of a list of customers:\ndef Int length(CustomerList list) = case list { Nil =\u0026gt; 0 ; Cons(n, ls) =\u0026gt; 1 + length(ls) ; _ =\u0026gt; 0 ; } ;  Several kinds of patterns are permitted on the left-hand side of case distinctions. In the example above, the first and second cases use a data constructor pattern. In the second case, this contains an unbound variable whose value is extracted and used on the right-hand side. The last case uses an underscore pattern containing an anonymous variable that matches anything. Naturally, it would have been possible to define a parametric version of Int length(List\u0026lt;T\u0026gt; list). This is left as an exercise to the reader. Here is another example illustrating the remaining patterns, that is, the literal pattern and the bound variable pattern:\ndef Int sign(Int n) = case n { 0 =\u0026gt; 0 ; n =\u0026gt; if (n \u0026gt; 0) then 1 else -1 ; } ;  The ABS parser does not attempt to establish whether case distinctions are exhaustive. If no pattern in a case expression matches, a runtime error results. It is up to the modeler to prevent this situation (in the near future, ABS will be equipped with the possibility of failure handling). Similarly, it is perfectly possible to define the following function:\ndef Int getPid(Customer c) = pid(c);  However, if c has any other type than Person(Int,Level) at runtime, an error will result. We close this section by illustrating a piece of syntactic sugar for associative collection types such as sets, bags, sequences, etc. To construct concrete elements of such datatypes one typically needs to iterate several binary constructors, such as Insert(1,Insert(2,Insert(3,EmptySet))). This is cumbersome. The following idiom defines an n-ary constructor that uses concrete list syntax as its argument. By convention, the constructor should have the same name as the type it is derived from, but in lower-case.\ndata Set\u0026lt;A\u0026gt; = EmptySet | Insert(A, Set\u0026lt;A\u0026gt;); def Set\u0026lt;A\u0026gt; set\u0026lt;A\u0026gt;(List\u0026lt;A\u0026gt; l) = case l { Nil =\u0026gt; EmptySet; Cons(hd, tl) =\u0026gt; Insert(hd, set(tl)); } ;  Errors are highlighted on the editor line where they occur as well as in the Problems tab of the messages subwindow\nSet\u0026lt;Int\u0026gt; s = set[1,2,3];  4.3 Modules If you tried to type in the previous examples into the ABS Eclipse editor you got parser errors despite the definitions being syntactically correct (similarly as in Fig. 5). This is, because any ABS definition must be contained in exactly one module. ABS is equipped with a simple syntactic module system that is inspired by that of Haskell [33]. To make the examples of the previous section work, simply add a module declaration like this as the first line of the file:\nmodule CustomerData;  Module names must be upper-case and define a syntactic scope until the end of the file or until the next module declaration, whatever comes first. Module names can also be part of qualified type names. Module declarations are followed by export and import directives. The former lists the types, type constructors, and functions that are visible to other modules, the latter lists the entities from other modules that can be used in the current module. With the type definitions of the previous section we might write:\nmodule CustomerData; export Standard, Customer, Company, getPid; ... module Test; import * from CustomerData; def Customer c1() = Company(2); def Customer c2() = Person(1,Standard); // erroneous  The module CustomerData exposes three of its constructors and a function while module Test imports anything made available by the former. The definition of c1 is correct, but the definition of c2 gives a parse error about a constructor that cannot be resolved, because Person is not exported. The from clause constitutes an unqualified import. Instead, it is also possible to make qualified imports. For example, we could have written:\nimport CustomerData.Company, CustomerData.Customer; def CustomerData.Customer c1() = CustomerData.Company(2);  In this case, however, one must also use qualified type names in the definitions as illustrated above. The ABS compiler knows one predefined module that does not need to be explicitly imported\u0026mdash;the ABS standard library ABS.StdLib. It contains a number of standard collection types, such as lists, sets, maps, together with the usual functions defined on them. It also contains some other types and functions that are used often. The standard library module is contained in a file named abslang.abs. To look up the definition of any standard type or function (or any other type or function, for that matter), simply move the cursor over the identifier in question and press F3. For example, pressing F3 over the identifier Cons in the definition of length in the previous section opens a new tab that contains abslang.abs and jumps to the line that contains the definition of the constructor Cons. This lookup functionality is, of course, well-known to users of the Eclipse IDE.\n4.4 Abstract Data Types The module system allows to define abstract data types by hiding the type constructors. This implies that only functions can be used to access data elements. Their explicit representation is hidden. Of course, one then needs to supply suitable constructor functions, otherwise, no new elements can be created at all. In the example of the previous section we might decide to expose only the types and constructor functions as follows:\nmodule CustomerData; export Customer, Level, createCustomer, createLevel; def Customer createCustomer(Int id, String kind) = ... ; def Level createLevel() = ... ;  We leave it as an exercise to write a suitable definition of createCustomer. As usual, the advantage of using abstract data types is that one can replace the definition of types without the need to change any client code.\n5 The OO-Imperative Layer 5.1 The Object Model ABS follows a strict programming to interfaces discipline [17]. This means that the only declaration types of objects are interface types. Consequentially, ABS classes do not give rise to type names. Apart from that, interface declarations are pretty standard and follow a Java-like syntax. They simply consist of a number of method signatures. Static fields are not permitted,(Foot: And neither are static classes and objects. Instead of static elements the ABS modeler should consider to use ADTs and functions.) but subinterfaces, even multiple subinterfaces, are permitted. Let us give an example that models the Customer type from previous sections in an object-oriented fashion:\nmodule CustomerIF; export Customer; import Level, createLevel from CustomerData; interface Customer { Int getId(); } interface IndvCustomer extends Customer {} interface CorpCustomer extends Customer { Level getLevel(); }  As can be seen, interfaces (and also classes) can be exported. In fact, this is necessary, if anyone outside their modules is to use them. It is possible to mix object and data types: data types may occur anywhere within classes and interfaces as long as they are well-typed. Less obviously, reference types may also occur inside algebraic data types. As seen earlier, it is perfectly possible to declare the following type:\ntype CustomerList = List\u0026lt;Customer\u0026gt;;  Keep in mind, though, that it is not allowed to call methods in function definitions. The reason is that method calls might have side effects. It was mentioned already that classes do not provide type names. They are only used for object construction. As a consequence, in ABS it is always possible to decide when a class and when an interface name is expected. Therefore, interfaces and classes may have the same name. We do not recommend this, however, because it dilutes the programming to interfaces discipline. It is suggested to use a base name for the interface and derive class names by appending \u0026ldquo;Impl\u0026rdquo; or similar. A class may implement multiple interfaces. Class constructors are not declared explicitly, instead, class declarations are equipped with parameter dec- larations that implicitly define corresponding fields and a constructor. Class definitions then consist of field declarations, followed by an initialization block and method implementations. Any of these elements may be missing. Hence, we can continue the example as follows:\nclass CorpIndvCustomerImpl(Int id) implements IndvCustomer, CorpCustomer { Level lv = createLevel(); // no initialization block Level getLevel() { return lv; } Int getId() { return id; } }  Here, the id field is modeled as a class parameter, because it is not possible to give a reasonable default value, which is otherwise required, because fields that have no reference type must be initialized. Reference type fields are initialized with null. In contrast to functions, method names need not (and cannot) be exported by modules. It is sufficient to get hold of an object in order to obtain access to the methods that are defined in its type. The most striking difference between ABS and mainstream OO languages is that in ABS there is no class inheritance and, therefore, also no code inheritance. So, how do we achieve code reuse? In ABS we decided to disentangle data design and functionality from the modeling of code variability. For the former, we use functions and objects (without code inheritance), whereas for the latter we use a layer on top of the core ABS language that permits to connect directly with feature models. This layer is discussed in Sect. 8. In a concurrent setting (see Sect. 6) one typically wants some objects to start their activity immediately after initialization. To achieve this in ABS, one can define a Unit run() method, which implicitly declares a class as active and lets objects execute the code in the body of the run method after initialization. Classes without a run() method are called passive and their objects react only to incoming calls.\n5.2 The Imperative Layer ABS has standard statements for sequential composition, assignment, while-loops, conditionals, synchronous method calls, and method return. To illustrate all of these, one can look at the implementation of method findCustomer( CustomerList) in class CorpIndvCustomerImpl (don\u0026rsquo;t forget to add it to the implemented interfaces as well to render it visible!).\nCustomer findCustomer(CustomerList cl) { Customer result; Int i = 0; while (i\u0026lt;length(cl)) { Customer curCust = nth(cl,i); Int curId = curCust.getId(); if (id==curId) {result = curCust;} } return result; }  In addition to the various constructs, we can illustrate several ABS-specific restrictions: it is necessary that the final statement in the method body is a return statement with the correct type. A typical ABS idiom is, therefore, to declare a local result variable. Neither for-loops nor breaks from loops are supported at the moment. To avoid going through the remaining list after the element has been found, one would need to add and test for a Bool found variable. Complex expressions are not allowed at the moment in tests of conditionals or loops. The workaround, as shown here, is to declare a local variable that holds an intermediate result. While these restrictions can be slightly annoying they hardly matter very much. It is likely that some of them will be lifted in the future, once it is better known what modelers wish. A more fundamental restriction concerns the usage of fields in assignment statements: assignments to fields and field lookups are only possible for the current object. Given a field f, an assignment of the form x = f; is always implicitly qualified as x = this.f; and an assignment of the form f = exp; is always implicitly qualified as this.f = exp;. This implies that fields in ABS are object private. They cannot be directly seen or be modified by other objects, not even by objects from the same class (as is possible even for private fields in Java). In other words, ABS enforces strong encapsulation of objects: it is only possible to view or change the state of another object via getter- and setter-methods. For example, it is not possible to change the second line in the body of the while-loop of findCustomer(CustomerList) as follows:\nInt curId = curCust.id;  The designers of ABS consider object encapsulation not as a restriction, but as a virtue: it makes all cross references between objects syntactically explicit. This avoids errors that can be hard to find. In addition it makes static analysis much more efficient, because any cross reference and possible side effect to a different object can be associated with a unique method contract. For the practicing ABS modeler object encapsulation is greatly alleviated by the method completion feature of the Eclipse editor: if one types the beginning of the example above \u0026ldquo;Int curId = curCust.\u0026ldquo;, then a pop-up menu will offer a selection of all methods that are known for objects of type Customer, the required getter-method getId() among them. If a suitable method is not found, then the modeler can take this as a hint that it needs to be implemented or added to the interface. ABS is a block-structured language. Blocks are delimited by curly braces (no semicolon afterward) and may appear at four different places in a program:\n as a way to group several statements and provide a scope for local variables\u0026ndash;blocks are necessary for bodies of loops and conditionals that have more than one statement; as method bodies; as the (optional) class initialization block, between field and method declarations; as an (optional) implicit \u0026ldquo;main\u0026rdquo; method at end of a module.  The last usage serves as an entry point for execution of ABS programs. At least one main block in one module is necessary for executing an ABS project, otherwise it is not clear which objects are to be created and executed. Any module that has a main block is selectable as an execution target via the Eclipse Run Configurations ... dialog or simply by right clicking on the desired module in the explorer and selection of Run As. We might complete the example by specifying the following main block for module CustomerIF:\n{ Customer c = new CorpIndvCustomerImpl(17); // create some customers Customer d = new CorpIndvCustomerImpl(16); CustomerList l = Cons(c,Cons(d,Nil)); // create list of customers Customer e = c.findCustomer(l); // we should find c in l }  This code illustrates at the same time the usage of the new statement, which works as in Java. As usual in Eclipse, pressing the F4 key displays the type hierarchy pertaining to a class or interface name at the cursor position.\n6 The Concurrency Layers 6.1 Background One of the most distinctive features of ABS is its concurrency model. If we look at commercial programming languages such as C, C++, or Java, one can observe that, despite intense efforts in the last decade, none of them has a fully formalized concurrency model. Even though there are promising efforts towards a formal concurrency model of Java [5], the details are so complex that they are likely to compromise usability of any resulting system. The reason is that current industrial programming languages have a very low-level concurrency model and do not natively support distributed computation. This has practical consequences, such as burdening the programmer with, for example, prevention of data races. A more fundamental problem is the impossibility to design a compositional proof system for such languages. By compositionality we mean that one can specify and verify the behavior of a single method in isolation from the rest of the system. This is a prerequisite for being able to deduce global behavior from the composition of local behavior. In a setting, where concurrent objects can arbitrarily cross-reference each other, this is hardly possible.\nArbitrarily complex, global invariants, might be needed to describe behavior. One approach to tackle the problem is to impose structure on concurrent objects and to make their dependencies syntactically explicit. In the realm of Java, JCoBox [39] is a suitable framework. It has been simplified and renamed into Concurrent Object Group (COG) in the context of ABS. COGs constitute the lower tier of the ABS concurrency model and are intended for closely cooperating concurrent tasks. A second shortcoming of mainstream programming languages is the lack of support for distributed computation, that is, asynchronous communication among nodes that do not share memory. This form of concurrency has been abstracted into the Actor model [23] and is realized with first-class support in recent languages such as Scala. ABS implements a version of Actor-based distributed computation where COGs form the primitive units of distribution. This constitutes the upper tier of the ABS concurrency model. Its main ideas are derived from the modeling language Creol [26].\n6.2 Component Object Groups An ABS Concurrent Object Group (COG) is a collection of tasks with shared memory and processor. This means that exactly one task is active at any given time and tasks can cross-reference each other. The situation can be visualized as in Fig. 6. Within a COG, synchronous as well as asynchronous method calls are permitted. For the former, we use the standard syntax target.method(arg1,arg2,...). Synchronous method calls within COGs represent sequential execution of code, that is, they block the caller and execute the code of the target until control is returned. Asynchronous method calls use the syntax target!method(arg1,arg2,...) and they cause the creation of a new task that is to execute the code of the target. Unlike in synchronous calls, execution of the code of the caller continues. The main point to understand about COGs is that multitasking is not preemptive (decided by a scheduler). Rather it is an explicit decision of the ABS modeler when control is transferred to another task. To this end, ABS provides scheduling statements that allow cooperative multitasking. In between the explicit scheduling points, only one task is active, signified by the (single) lock of a COG being set to \u0026amp;#8868. As a consequence, data races between synchronization points simply cannot happen, which was an important design goal of ABS.\n6.3 Scheduling and Synchronization So, how are scheduling points specified in ABS? It is here that we encounter a second, central concurrency principle of ABS: communication and synchronization are decoupled. This is done via future types [12]. For any ABS type T a legal type name is Fut\u0026lt;T\u0026gt; and one can assign to it the result of any asynchronous method call with return type T. A variable declared with type Fut\u0026lt;T\u0026gt; serves as a reference to the future result of an asynchronous call and allows to retrieve it once it will have been computed. For example, the final line of the example on p. 15 can be rewritten to:\nFut\u0026lt;Customer\u0026gt; e = c!findCustomer(l); // do something else ...  Now the call creates a new task in the current COG and declares e as a future reference to its final result. The following code is executed immediately. The future mechanism allows to dispatch asynchronous calls, continue with the execution, and then synchronize on the result, whenever it is needed. Synchronization is achieved by the command await g, where g is a polling guard. A guard is a conjunction of either side-effect free boolean expressions or future guards of the form f?. In the latter, f is a variable that has a future type. If the result to which f? is a reference is ready and available, then the expression evaluates to true. When the guard of an await statement evaluates to true, the computation simply continues. If, however, a guard is not true, then the current task releases the lock of its COG and gives another task in that COG the chance to continue. When later the task is scheduled gain, the guard is re-evaluated, and so on, until it finally becomes true. We call this a conditional scheduling point or conditional release point. To continue the previous example we could write:\nawait e?;  If the asynchronous call to findCustomer(l) has finished, then execution simply continues. Otherwise, the lock of the current COG is set to ⊥ and the processor is free to proceed with another task. For efficiency reasons ABS allows only monotonic guards and only conjunctive composition. Once the result from an asynchronous call is available, it can be retrieved with a get-expression that has a future variable as its argument. In the example this may look as follows:\nCustomer f = e.get;  In summary, the following programming idiom for asynchronous calls and retrieving their results is common in ABS:\nFut\u0026lt;T\u0026gt; v = o!m(e); ... ; await v?; r = v.get;  ABS does not attempt to check that each get expression is guarded by an await statement. So what happens when the result of an asynchronous call is not ready when get is executed? The answer is that the execution of the COG blocks. The difference between suspension and blocking is that in the latter case no task in same COG can continue until the blocking future is resolved. Sometimes it is convenient to create an unconditional scheduling point, for example, to insert release points into long running sequential tasks. The syntax for unconditional scheduling statements in ABS is \u0026ldquo;suspend;\u0026rdquo;.\n6.4 Object and COG Creation In the previous section we discussed the fundamental concurrency model of ABS, which is based on COGs. Whenever we create an object with the new statement, it is by default created in the same COG as the current task (see upper part of Fig. 7). This is not adequate for modeling distributed computing, where each node has its own computing resources (processor) and nodes are loosely coupled. In an ABS model of a distributed scenario we associate one COG with each node. New COGs are implicitly created when specifying the cog keyword at object creation (see lower part of Fig. 7): this creates a new COG and places the new object inside it. At the moment, COGs are not first-class objects in ABS and are accessible only implicitly through their objects.(Foot: There is an extension for ABS runtime objects that allows explicit and dynamic grouping of COGs [28].) As a consequence, it is not possible to re-enter via recursive calls into the same execution thread. This is the reason why a simple binary lock for each COG is sufficient. Let us extend our running example with an Account class and COG creation:\nmodule Account; interface Account { Int getAid(); Int deposit(Int x); Int withdraw(Int x); } class AccountImpl(Int aid, Int balance, Customer owner) implements Account { ... } { [Near] Customer c = new CorpIndvCustomerImpl(3); [Far] Account a = new cog AccountImpl(1,0,c); Fut\u0026lt;Int\u0026gt; dep = a!deposit(17); Fut\u0026lt;Int\u0026gt; with = a!withdraw(17); await dep? \u0026amp; with?; Int x = dep.get; Int y = with.get; Int net = x + y; }  We create an account objects in a different COG from the current one. Note that there is no sharing of objects between COGs, so that the variable c provides no alias to the object parameter c in the constructor AccountImpl(1,0,c). The tasks resulting from the two asynchronous calls will be executed on the same node, which is different from the current one. A conjunctive guard ensures that the retrieval of the results is safe. It is possible to visualize the execution of ABS code in two ways. To start the graphical ABS Debugger, simply right click on the file with the Account module in the explorer and select Run As|ABS Java Backend (Debug). This will automatically switch to the ABS Debug Perspective (see Fig. 8) and start the Eclipse debugger.\nAll the usual features of a graphical debugger are available: navigation, breakpoints, state inspection, etc. If instead, the backend Run As|ABS Java Backend (Debug with Sequence Diagram) is chosen, then in addition a UML sequence diagram that has a lifeline for each created COG is created and dynamically updated after each debugger step, see Fig. 9. Synchronous method calls to targets not in the current COG make no sense and are forbidden. For example, if we replace one of the asynchronous calls above with a.deposit(17), a runtime error results. One possibility to avoid this is to annotate declarations with one of the types Near or Far, as shown above. This tells the compiler that, for example, a is in a different COG and cannot be the target of a synchronous call. Obviously, it is tedious to annotate all declarations; moreover, the annotations tend to clutter the models. To address this problem, ABS implements a far/near analysis, which automatically infers a safely approximated (in case of doubt, use \u0026ldquo;far\u0026rdquo;) location type [41]. The inferred types are displayed in the Eclipse editor as superscripts (\u0026ldquo;N\u0026rdquo; for near, \u0026ldquo;F\u0026rdquo; for far) above the declared types. All annotations in the example can be inferred automatically: simply delete the annotations to see it. It is also possible to annotate a declaration with Somewhere, which overrides the type inference mechanism and tells the compiler not to make any assumptions. Default is the annotation Infer, but this can be changed in the ABS project properties. It is entirely possible that execution of an ABS model results in a deadlock during runtime, as is exemplified by the model in Fig. 10. Objects c, e and d are in different COGs, say cog_c and cog_d . The task that executes m1 is in cog_c while the task executing m2 is put into the second COG cog_d . During this execution m3 is called on e, which is located in the first COG cog_c . For m3 to proceed it needs to obtain the lock of cog_c , but this is not possible, because m1 still waits for the result of m2. Hence, neither COG can progress. Deadlocks are very difficult to avoid in general. Deadlock-free concurrent languages tend to be too restrictive to be usable and, unlike data race-freeness, are not a practical option.\nclass C { C m1(C b, C c) { Fut\u0026lt;C\u0026gt; r = b!m2(c); return r.get; } C m2(C c) { Fut\u0026lt;C\u0026gt; r = c!m3(); return r.get; } C m3() { return new C(); } } { C c = new C(); C d = new cog C(); C e = new C(); c!m1(d,e); }  Fig. 10. Example for deadlock in ABS\nIn ABS many deadlocks can be avoided by supplying enough release points. In the example above it is sufficient to guard one of the get expressions. In addition, there is an automatic deadlock analysis for ABS [18] that is currently being implemented.\n6.5 Formal Semantics of Concurrent ABS The ABS language has a mathematically rigorous, SOS-style semantics [13, 25]. This tutorial introduction is not the place go into the details, but we sketch the main ideas. The central issue is to give an appropriate structure to the terms that represent ABS runtime configurations. They are collections over the following items:\nCOGs are identified simply by a name b for their lock whose value can be either ⊤ or ⊥. Objects have a name o, need to have a reference to their COG b, to their class C, and they also have a local state σ that holds the current field values. Tasks have a name n, a reference to their COG b and to the object o whose code they are executing. They also have a state σ withe values of local variables and a program counter s that gives the next executable instruction. Task names n also double as futures, because they contain exactly the required information. A runtime configuration may consist of any number of the above items. The operational semantics of ABS is given by rewrite rules that match the next executable statement of a task (and thereby also the current COG and object). A typical example is the rewrite rule that realizes creation of a new COG:\nwhere:\n \\(b\u0026rsquo;, o\u0026rsquo;, n\u0026rsquo;\\) new;\n \\(\\overline{T f}; s\u0026rsquo;\\) init block of class \\(C\\) and \\(\\sigma\u0026rsquo;_{init}\\) binds constructor parameters \\(v\u0026rsquo;\\);\n \\(\\sigma\u0026rsquo;_{init} = \\overline{T f}\\);\n \\(s_{task} = s\u0026rsquo;\\{\\mathbf{this}\\, / o\u0026rsquo;;\\mathbf{suspend}\\}\\).\n  The rule matches a new cog statement in task \\(n\\), COG \\(b\\), current object \\(o\\), and subsequent statements s. First we need to create a new COG with a fresh name \\(b\u0026rsquo;\\) and a new object \\(o\u0026rsquo;\\) of class \\(C\\). The new COG starts immediately to execute the initialization code of its class \\(C\\) in a new task \\(n\u0026rsquo;\\), therefore, the lock of \\(b\u0026rsquo;\\) is set to ⊤. Note that the current object this must be instantiated now to the actual object \\(o\u0026rsquo;\\). After initialization, execution is suspended. The original task \\(n\\) immediately continues to execute the remaining code s as there is no release point here. The value of the object reference z is replaced with the new object \\(o\u0026rsquo;\\).\n7 Extensions 7.1 Pluggable Type System All declarations (fields, methods, classes, interfaces) in ABS can carry annotations. These are simply expressions that are enclosed in square brackets. The location type system in Sect. 6.4 provided examples. Other annotations can be logical expressions that are used as assertions, contracts, or invariants during verification or runtime assertion checking. This goes beyond this tutorial. The location types are a so-called pluggable type system. Such type systems can be realized easily in ABS via meta annotations. The special annotation [TypeAnnotation] declares the data type definition immediately following it to be a definition for type annotations and makes the parser aware of it. For example, the location type system is declared as follows:\n[TypeAnnotation] data LocationType = Far | Near | Somewhere | Infer; // usage [LocationType: Near] T n;  7.2 Foreign Language Interface As a modeling language ABS does not contain mechanisms for I/O, because these are typically implementation-dependent. Of course, one often would like to have some output from the execution of an ABS model. This is possible with a general foreign language interface (FLI) mechanism that not only can be used to implement I/O for ABS, but to connect ABS models with legacy code in implementation languages in general. At the moment, the ABS FLI is realized for the Java language. An ABS class that is to be implemented in Java needs three ingredients:\n import of helper functions and classes from the module ABS.FLI; declaration as being foreign by the annotation [Foreign]; default ABS implementations of all interface methods.  A simple example can look as follows:\nimport * from ABS.FLI; interface Hello { String hello(String msg); } [Foreign] class HelloImpl implements Hello { String hello(String msg) { return \u0026quot;default implementation\u0026quot;; } } { Hello h = new HelloImpl(); h.hello(\u0026quot;Hi there\u0026quot;); }  The default implementation is used for simulation of ABS code without Java. It is now possible to implement a Java version of the HelloImpl class in a Java project and to connect that project with ABS. The details of how this is done are explained at the HATS tools site. Basically, one extends the Java class HelloImpl_c that was generated by the ABS Java backend with a new implementation of the Java method hello(String). By convention, the Java methods carry the prefix fli.\nimport abs.backend.java.lib.types.ABSString; import abs.backend.java.lib.runtime.FLIHelper; import Test.HelloImpl_c; public class HelloImpl_fli extends HelloImpl_c { @Override public ABSString fli_hello(ABSString msg) { FLIHelper.println(\u0026quot;I got \u0026quot;+msg.getString()+\u0026quot; from ABS\u0026quot;); return ABSString.fromString(\u0026quot;Hello ABS, this is Java\u0026quot;); } }  On the Java side any Java construct can be used. ABS provides a Java package abs.backend.java.lib.types containing declarations of the built-in ABS types usable in Java such as ABSString. Execution of the ABS main block above will now cause the Java output \u0026ldquo;I got Hi there from ABS\u0026rdquo; to be printed on the system console.\n8 Product Line Modeling with ABS 8.1 Product Line Engineering One of the aims of ABS is to provide a uniform and formal framework for product line engineering (PLE) [35], a practically highly successful software reuse methodology. In PLE one distinguishes two separate development phases (see Fig. 11). During family engineering one attempts to distill the commonality among different products into a set of reusable artifacts. At the same time, the variability of the product line is carefully planned. This is typically done in a feature-driven manner, and the relation of features, as well as constraints in their combination is documented in a feature model with the help of feature description languages [40]. In the application engineering phase, individual products are being built by selecting features and by combining the artifacts that implement them in a suitable way. One drawback of current practice in PLE is that feature description languages make no formal connection between features and their implementation. This renders products assembly ad hoc and error-prone. That issue is addressed in ABS with language extensions for modeling of features, for connecting features to their realization, as well as for feature selection and product specification [10]. In this section we introduce the PLE extensions of ABS. A fuller discussion of various approaches to achieve greater flexibility in object-oriented modeling is contained in the chapter by Clarke in this volume [8]. If one wants to maintain a connection between features and code, then the central issue are the mechanisms being used to compose the code corresponding to new features with the existing code. In current practice, this is often done by \u0026ldquo;glue code\u0026rdquo; written in scripting languages. ABS has the ambition that models can be statically analyzed. This means that the feature composition mechanism must be well-structured and represent a suitable match for the analysis methods used in ABS [14].\nSuch a mechanism is delta-oriented programming (DOP) [36, 38], because it allows to modify object-oriented code in a structured manner at the granularity of fields and methods, which is adequate for the contract-based specification approach in ABS [21]. To summarize, the ABS-extensions used to model product lines consist of four elements [9, 10], which we describe now in turn:\n A feature description language A language for deltas that modify ABS models A configuration language connecting features with the deltas that realize them A language for product configuration  8.2 Feature Description Modern software development processes, notably agile processes and PLE, tend to be feature-driven. A number of mature and useful formalisms for feature description have been developed in the last decade. For ABS we use a slight modification of the textual variability language (TVL) [11], which has the advantage of having a formal semantics and a textual representation. The feature description language used in ABS is called μTVL and differs from TVL in that (i) attribute types that are not needed are omitted and (ii) the possibility to have multiple root features. These are useful to model orthogonal variability in product lines. Let us build a product line based on the Account interface from Sect. 6.4. Assume we want to distinguish between checking and saving accounts. The latter may pay interest, whereas the former usually don\u0026rsquo;t. Optionally, a checking ac- count (but not a saving account) may permit an overdraft or incur fees for transactions. A graphical representation of the Account feature model is in Fig. 12. The textual rendering in μTVL looks as follows:\nroot Account { group allof { Type { group oneof { Check {ifin: Type.i == 0;}, Save {ifin: Type.i \u0026gt; 0; exclude: Overdraft;} } Int i; // interest rate }, opt Fee {Int amount in [0..5];}, opt Overdraft } }  In μTVL one represents each subhierarchy in the feature tree by a group of features, which can be further qualified as inclusive (allof) or alternative (oneof). Within a group there is a comma-separated list of feature declarations. Each feature declaration may be optional (opt) and have restrictions (ifin:), exclusions (exclude:), or requirements (include:). Feature parameters are declared after the declaration of a subhierarchy. A feature model appears in a separate file with extension .abs. The Eclipse editor supports syntax and parse error highlighting. There can be several feature files with feature declarations. These are interpreted as orthogonal feature hierarchies that are all part of the same feature model. The semantics of feature models is straightforward by translation into a boolean/integer constraint formula, see [10, 11]. For example, the feature model above is characterized by the following formula: 0 ≤ Account ≤ 1 ∧ Type → Account ∧ Overdraft† → Account ∧ Fee† → Account ∧ Type + Fee† + Overdraft† = 3 ∧ 0 ≤ Type ≤ 1 ∧ Check → Type ∧ Save → Type ∧ Save → ¬Overdraft ∧ Check + Save = 1 ∧ 0 ≤ Check ≤ 1 ∧ 0 ≤ Save ≤ 1 ∧ 0 ≤ Fee† ≤ 1 ∧ 0 ≤ Overdraft† ≤ 1 ∧ Fee → Fee† ∧ Overdraft → Overdraft† ∧ 0 ≤ Save ≤ 1 ∧ 0 ≤ Check ≤ 1 ∧ Fee → (Fee.amount \u0026gt;= 0 ∧ Fee.amount \u0026lt;= 5) ∧ Check → (Type.i = 0) ∧ Save → (Type.i \u0026gt; 0). It is easy to check validity of a given feature selection for a feature model F : for any selected feature f and parameter value p := v one simply adds f = 1 ∧ p = v to the semantics of F and checks for satisfiability with a constraint solver. The constraint solver of ABS can:\n find all possible solutions for a given feature model and check whether a feature selection is a solution of a feature model.  The latter check is performed implicitly in the ABS Eclipse plugin, whenever the user requests to build a product based on a specific feature selection (see Sect. 8.5).\n8.3 Delta Modeling As mentioned above, the realization of features in ABS is done with delta modules (or deltas, for short), a variant of delta-oriented programming (DOP). This constitutes the main reuse principle of ABS and replaces other mechanisms such as code inheritance, traits, or mixins. In delta modeling we assume that one outcome of the family engineering phase (see Fig. 11) is a core or base product with minimal functionality. Product variants with additional features are obtained from it by applying one or more deltas that realize the desired features, as illustrated in Fig. 13. In ABS, deltas have the following capabilities:\n Delta modules may add, remove or modify classes and interfaces Permitted class modifications are:  adding and removal of fields adding, removal and modification of methods extending the list of implemented interfaces   The actual reuse mechanism is located in the modification of methods: the description of a method modification in a delta can access the most recent incarnation of that method in a previous delta by the statement original(...);. This will cause the compiler to insert the body of the referred method at the time when the deltas are applied. The signature of original() must be identical to the one of the modified method. The compiler checks the applicability of deltas and ensures well-typedness of the resulting code. It is because of this reuse mechanism that once can say that the granularity of delta application is at the level of methods. There is a certain analogy between original() in DOP and super()-calls in OO languages with code inheritance. The crucial difference is that original() references are resolved at compile time (product build time), while super()-calls occur at runtime. As a consequence, there is a runtime penalty for the latter. Assume we have the following implementation of the withdraw(Int) method of the Account interface, which ensures that we cannot withdraw more than the current balance:\nclass AccountImpl(Int aid, Int balance, Customer owner) implements Account { Int withdraw(Int x) { if (balance - x \u0026gt;= 0) { balance = balance - x; } return balance; } }  Now we would like to create a delta module that realizes the feature Fee. We need to modify withdraw(Int), which can be achieved by the following delta:\ndelta DFee(Int fee); // Implements feature Fee uses Account; modifies class AccountImpl { modifies Int withdraw(Int x) { Int result = x; if (x\u0026gt;=fee) result = original(x+fee); return result; } }  One or more features can be put into a file with extension .abs. The connection between different deltas and a base implementation is given via the uses clause that refers to the module where the base is found. Like classes, deltas can have parameters, however, these are not fields, but are instantiated at product build time. Normally, there is a correspondence between the parameters of deltas and those of the features they are supposed to implement. The modified withdraw(Int) method is implemented by a suitable call to the original version after a check that the withdrawn amount is not trivially small. We must declare a result variable to ensure that the return statement is last. Assume further we want to realize the Save feature. One must ensure that the interest rate is set to 0. ABS deltas at this time do not support to add or modify class initialization blocks. To change the initial value of a field, we simply remove the field declaration and add it again with a suitable initial value:\ndelta DSave(Int i); // Implements feature Save uses Account; modifies class AccountImpl { removes Int interest; adds Int interest = i; }  Of course, we assume here that the interest field has been added in the first place in the earlier delta DType. This requires to specify and check temporal constraints on the application of deltas as we shall see in the following section. Application of a concrete delta is illustrated with DSave in Fig. 14. Syntax and parse error highlighting for delta modules works as usual. Automatic completion works as well, but it is only done relative to the base product.\nThe reason is that before product build time, the compiler cannot know which deltas have been applied before. For the same reason, only a limited amount of type checking is done. Research to lift type checking to the family level is under way [29, 37].\n8.4 Product Line Configuration So far, we have two models relating to product lines: the feature model and the delta model, that is, the feature implementation. Unlike any other formalism we are aware of, in ABS we can make a formal connection between these. This is the key to being able to analyze whole product lines and not merely individual products. In ABS, the connection between features and their realization (illustrated in Fig. 15) is done in a dedicated product line configuration file. This makes debugging easy, because all information about the realization of a given feature model is collected in one place. To establish a connection between features and deltas, the configuration files need to specify three things:\n they must associate features with their implementing delta modules by application conditions; they need to resolve conflicts in the application order by giving partial temporal constraints on delta application; they need to pass the attribute values of features to the parameters of the delta modules.  We can illustrate all three aspects with our running example. The following file (again, use file extension .abs) defines a product line named Accounts based on the five features of the feature model in Fig. 12.\nproductline Accounts; features Type, Fee, Overdraft, Check, Save; delta DType (Type.i) when Type; delta DFee (Fee.amount) when Fee; delta DOverdraft after DCheck when Overdraft; delta DSave (Type.i) after DType when Save; delta DCheck after DType when Check;  For each delta that is to be used for implementing any of the features one specifies:\n the application conditions (when clauses), that is, the feature(s) that are being realized by each delta and whose presence triggers delta application; the delta parameters which are derived from feature attribute values; a strict partial order of delta application (after clauses) to ensure well-definedness of delta applications and resolve conflicts.  In the example, there is a one-to-one correspondence between deltas and features, which is reflected in the application conditions. Likewise, the feature attributes Type.i and Fee.amount directly can be used as parameters of the corresponding deltas. The temporal constraints of DSave and DCheck ensure that the field interest is present. The constraint of DOverdraft makes sure that this delta is only applied to checking accounts. It would also have been possible to express this constraint at the level of the feature model with an includes: clause. It is up to the modeler to decide whether a given constraint is a property of the feature model or of the product line.\n8.5 Product Selection The final step in PLE with ABS is product selection. Whereas the activities that took place until now can be viewed as mostly being part of family engineering, the selection process is always part of application engineering.\nTo create a product it is sufficient to list the features that should be realized in it and to instantiate the feature attributes with concrete values. The syntax is very simple and self-explaining. As any other ABS file, product selection files have the .abs extension and there is Eclipse support for syntax and parse error highlighting. Some examples for the Accounts product line are as follows:\nproduct CheckingAccount (Type{i=0},Check); product AccountWithFee (Type{i=0},Check,Fee{amount=1}); product AccountWithOverdraft (Type{i=0},Check,Overdraft); product SavingWithOverdraft (Type{i=1},Save,Overdraft);  The simplest product that can be built is CheckingAccount. The second product above extends it by charging a fee of one unit per transaction. The ABS compiler uses the product selection file and the other related files to create a \u0026ldquo;flattened\u0026rdquo; ABS model where all deltas have been applied such that it contains only core ABS code. In a first step, the compiler checks that the product selection is valid for the given feature model as described in Sect. 8.2. It then uses the product line configuration file to decide which deltas need to be applied and how they are instantiated. The partial order on the deltas is linearized. It is up to the modeller to ensure (possibly, by adding temporal constraints) that different linearizations do not lead to conflicting results. Finally, the resulting core ABS model is type-checked and compiled to one of the ABS backends in the standard way. As all parts of the ABS language the product line modeling languages have a formal semantics\u0026mdash;the details are found in [10]. Different products can be selected in the Run|Run Configurations ... dialog from the ABS Product menu. Invalid product selections or type errors in the configuration files will be displayed at this stage. For example, selection of the SavingWithOverdraft product above results in an error, because the constraints in the feature model are not satisfied.\nAfter selection of a valid product one can run and debug the resulting core ABS model as described earlier. The ABS compiler additionally creates always as base product that corresponds to the given ABS model without any features or deltas. This product appears under the name \u0026lt;base\u0026gt; in the product selection menu. If we execute the main class of the Account module in Sect. 6.4 in the base product, we obtain the result 37 in the variable net, whereas if we run the product AccountWithFee, we obtain 34. A current limitation of the Eclipse ABS plugin is that the debugger correctly displays the runtime configuration and the values of variables of products, but in the editor window only the core product is displayed.\n9 Concluding Remarks In this tutorial we gave an introduction to the abstract modeling language ABS. Uniquely among current modeling languages, ABS has a formal semantics and covers the whole spectrum from feature modeling to the generation of executable code in Java. Development of ABS models is supported by an Eclipse plugin. A very important point is that ABS offers a wide variety of modeling options in a uniform, homogeneous framework, see Fig. 17. This allows to select an appropriate modeling style for each modeled artifact. It also supports rapid prototyping and design-time analysis, because ADT-based models can be refined later (dashed arrow). Of course, as any other formalism, ABS has also limitations: it is not suitable to model low-level, thread-based concurrency with shared data. Hence, ABS is not suitable to model multi-core applications or system libraries. In this sense, approaches such as [5] are complementary to ABS. As mentioned earlier, the analysis capabilities and the ABS runtime component layer are beyond this tutorial, but some chapters in this volume cover part of the material.\nAcknowledgments The development and implementation of ABS was a collaborative effort of the many researchers involved in the HATS project. While the text of this tutorial has been written from scratch by the author, it could never have been done without the background of all the papers, presentations, and discussions provided by many colleagues. Special thanks go to the main contributors to Work Package 8: Frank de Boer, Einar Broch Johnsen, and Ina Schaefer.\nFurther Reading This paper is a tutorial on ABS and not a language specification nor a formal definition. A more technical and more detailed description of ABS and its tool set is contained in the paper trio [10, 20, 25]. The most detailed document about ABS that also contains a formal semantics is [13]. The official ABS Language Specification is [2]. Finally, for several case studies done with ABS, please look here [15]. It is stressed at several places in this tutorial that ABS has been designed with the goal of permitting automatic static analyses of various kinds. This tutorial concentrates on the ABS language and its development environment. In the paper by Albert in this volume [4] automated resource analysis for ABS is explained in detail. Information on deadlock analysis and formal verification of ABS can be found in [14]. The chapter by Poetzsch-Heffter in this volume [34] contains a general discussion of verification of concurrent open systems.\n"
},
{
	"uri": "https://abs-models.org/getting_started/docker/",
	"title": "Running a Browser-Based IDE",
	"tags": [],
	"description": "",
	"content": " The collaboratory is a browser-based development environment for ABS. It integrates an editor, the syntax checker and simulator, and the SACO resource analysis tool.\nRunning the Collaboratory using Docker To run the collaboratory, first install docker from https://www.docker.com. Then, run the following command in a terminal window:\ndocker run -d --rm -p 8080:80 --name collaboratory abslang/collaboratory:latest  When the command has finished, connect a browser to http://localhost:8080 and start using ABS!\nTo stop the collaboratory, use the following command:\ndocker stop collaboratory  "
},
{
	"uri": "https://abs-models.org/getting_started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " There are various ways of running ABS models.\nUse On-Line Tools The simplest way to use the ABS tools is on-line, in the collaboratory. This means you only need a modern browser to start experimenting with ABS. The tools work best with Firefox and Chrome.\nAn introduction and link to the collaboratory can be found at http://abs-models.org/laboratory/.\n Installing Command-Line Tools  Many of the tools can be run from the command line. This chapter describes how to run various tools on a local machine. Installing the ABS Compiler To install the ABS compiler, install the Java 8 JDK and Erlang (version 21 or higher). Then, clone the git repository and build the compiler: git clone https://github.com/abstools/abstools.git cd abstools ./gradlew assemble After a successful build, there is an absc shell script in the abstools/frontend/bin/bash/ directory that invokes the ABS compiler.\n Running a Browser-Based IDE  The collaboratory is a browser-based development environment for ABS. It integrates an editor, the syntax checker and simulator, and the SACO resource analysis tool. Running the Collaboratory using Docker To run the collaboratory, first install docker from https://www.docker.com. Then, run the following command in a terminal window: docker run -d --rm -p 8080:80 --name collaboratory abslang/collaboratory:latest When the command has finished, connect a browser to http://localhost:8080 and start using ABS!\n Installing Editor Support  We provide support for Emacs, Atom and Visual Studio Code. Emacs The abs-mode package provides support for ABS in the Emacs editor. Installation instructions are at https://github.com/abstools/abs-mode. Atom The Atom editor support can be found at https://github.com/abstools/language-abs. ABS support for Atom currently cannot be installed from the offical Package repository and has to be installed manually; see https://github.com/abstools/language-abs for instructions. Visual Studio Code ABS editing support for Visual Studio Code is at https://github.\n "
},
{
	"uri": "https://abs-models.org/documentation/tutorials/resources/",
	"title": "Resource Modeling Tutorial",
	"tags": [],
	"description": "An introduction to time and resource modeling in ABS.",
	"content": " Core ABS   ABS is a modeling language which combines functional and imperative programming styles to develop high-level executable models. Concurrent object groups execute in parallel and communicate through asynchronous method calls. To intuitively capture internal computation inside a method, we use a simple functional language based on user-defined algebraic data types and functions. Thus, the modeler may abstract from the details of low-level imperative implementations of data structures, and still maintain an overall object-oriented design which is close to the target system. At a high level of abstraction, concurrent object groups typically consist of a single concurrent object; other objects may be introduced into a group as required to give some of the algebraic data structures an explicit imperative representation in the model. In this tutorial, we aim at high-level models and the groups will consist of single concurrent objects. The functional sublanguage of ABS consists of a library of algebraic data types such as the empty type Unit, booleans Bool, integers Int, parametric data types such as sets Set\u0026lt;A\u0026gt; and maps Map\u0026lt;A\u0026gt; (given a value for the type variable A), and (parametric) functions over values of these data types. For example, we can define polymorphic sets using a type variable A and two constructors EmptySet and Insert, and a function contains which checks whether an element el is in a set ss recursively by pattern matching over ss: data Set\u0026lt;A\u0026gt; = EmptySet | Insert(A, Set\u0026lt;A\u0026gt;); def Bool contains\u0026lt;A\u0026gt;(Set\u0026lt;A\u0026gt; ss, A el) = case ss { EmptySet =\u0026gt; False ; Insert(el, _) =\u0026gt; True; Insert(_, xs) =\u0026gt; contains(xs, el); };   Here, the cases p=\u0026gt;exp are evaluated in the listed order, underscore works as a wild card in the pattern p, and variables in p are bound in the expression exp. The imperative sublanguage of ABS addresses concurrency, communication, and synchronization at the concurrent object level in the system design, and defines interfaces and methods with a Java-like syntax. ABS objects are active; i.e., their run method, if defined, gets called upon creation. Statements are standard for sequential composition s1;s2, assignments x=rhs, and for the skip, if, while, and return constructs. The statement suspend unconditionally suspends the execution of the active process of an object by adding this process to the queue, from which an enabled process is then selected for execution. In await g, the guard g controls the suspension of the active process and consists of Boolean conditions b and return tests x? (see below). Just like functional expressions e, guards g are side-effect free. If g evaluates to False, the active process is suspended, i.e., added to the queue, and some other process from the queue may execute. Expressions rhs include the creation of an object group new C(e), object creation in the group of the creator new local C(e), method calls o!m(e) and o.m(e), future dereferencing x.get, and pure expressions e apply functions from the functional sublanguage to state variables. Communication and synchronization are decoupled in ABS. Communication is based on asynchronous method calls, denoted by assignments f=o!m(e) to future variables f. Here, o is an object expression and e are (data value or object) expressions providing actual parameter values for the method invocation. (Local calls are written this!m(e).) After calling f=o!m(e), the future variable f refers to the return value of the call and the caller may proceed with its execution without blocking on the method reply. There are two operations on future variables, which control synchronization in ABS. First, the guard await f? suspends the active process unless a return to the call associated with f has arrived, allowing other processes in the object group to execute. Second, the return value is retrieved by the expression f.get, which blocks all execution in the object until the return value is available. The statement sequence x=o!m(e);v=x.get encodes commonly used blocking calls, abbreviated v=o.m(e) (often referred to as synchronous calls). If the return value of a call is without interest, the call may occur directly as a statement o!m(e) with no associated future variable. This corresponds to message passing in the sense that there is no synchronization associated with the call. Real-Time ABS   Real-Time ABS is an extension of ABS which captures the timed behavior of ABS models. An ABS model is a model in Real-Time ABS in which execution takes zero time; thus, standard statements in ABS are assumed to execute in zero time. Timing aspects may be added incrementally to an untimed behavioral model. Our approach extends the distributed concurrent object groups in ABS with an integration of both explicit and implicit time. Deadlines   The object-oriented perspective on timed behavior is captured by deadlines to method calls. Every method activation in Real-Time ABS has an associated deadline, which decrements with the passage of time. This deadline can be accessed inside the method body with the expression deadline(). Deadlines are soft; i.e., deadline() may become negative but this does not in itself block the execution of the method. By default the deadline associated with a method activation is infinite, so in an untimed model deadlines will never be missed. Other deadlines may be introduced by means of call-site annotations. Real-Time ABS introduces two new data types into the functional sublanguage of ABS: Time, which has the constructor Time(r), and Duration, which has the constructors InfDuration and Duration(r), where r is a value of the type Rat of rational numbers. The accessor functions timeVal and durationValue return r for time and duration values Time(r) and Duration(r), respectively. Let o be an object which implements a method m. Below, we define a method n which calls m on o and specifies a deadline for this call, given as an annotation and expressed in terms of its own deadline. Remark that if its own deadline is InfDuration, then the deadline to m will also be unlimited. The function scale(d,r) multiplies a duration d by a rational number r (the definition of scale is straightforward). Int n (T x){ [Deadline: scale(deadline(),0.9)] return o.m(x); }  Explicit Time   In the explicit time model of Real-Time ABS, the execution time of computations is modeled using duration statements duration(e1,e2) with best- and worst-case execution times e1 and e2. These statements are inserted into the model, and capture execution time which does not depend on the system’s deployment architecture. Let f be a function defined in the functional sublanguage of ABS, which recurses through some data structure x of type T, and let size(x) be a measure of the size of this data structure x. Consider a method m which takes as input such a value x and returns the result of applying f to x. Let us assume that the time needed for this computation depends on the size of x; e.g., the computation time is between a duration 0.5*size(x) and a duration 4*size(x). An interface I which provides the method m and a class C which implements I, including the execution time for m using the explicit time model, are specified as follows: interface I { Int m(T x) } class C implements I { Int m (T x){ duration(0.5*size(x), 4*size(x)); return f(x); } }  Implicit Time   In the implicit time model of Real-Time ABS, the execution time is not specified explicitly in terms of durations, but rather observed on the executing model. This is done by comparing clock values from a global clock, which can be read by an expression now() of type Time. We specify an interface J with a method p which, given a value of type T, returns a value of type Duration, and implement p in a class D such that p measures the time needed to call the method m above, as follows: interface J { Duration p (T x) } class D implements J (I o) { Duration p (T x){ Time start; Int y; start = now(); y=o.m(x); return timeDifference(now(),start); } }   Observe that by using the implicit time model, no assumptions about execution times are specified in the model above. The execution time depends on how quickly the method call is effectuated by the called object. The execution time is simply measured during execution by comparing the time before and after making the call. As a consequence, the time needed to execute a statement with the implicit time model depends on the capacity of the chosen deployment architecture and on synchronization with (slower) objects. Modeling Deployment Architectures in ABS  Deployment Components   A deployment component in Real-Time ABS captures the execution capacity associated with a number of concurrent object groups. Deployment components are first-class citizens in Real-Time ABS, and provide a given amount of resources which are shared by their allocated objects. Deployment components may be dynamically created depending on the control flow of the ABS model or statically created in the main block of the model. We assume a deployment component environment with unlimited resources, to which the root object of a model is allocated. When objects are created, they are by default allocated to the same deployment component as their creator, but they may also be allocated to a different component. Thus, a model without explicit deployment components runs in environment, which does not impose any restrictions on the execution capacity of the model. A model may be extended with other deployment components with different processing capacities. Given the interfaces I and J and classes C and D defined in above, we can for example specify a deployment architecture in which two C objects are deployed on different deployment components server1 and server2, and interact with the D objects deployed on a deployment component clientServer. Deployment components in Real-Time ABS have the type DC and are instances of the class DeploymentComponent. This class takes as parameters a name, given as a string, and a set of restrictions on resources. The name is mainly used for monitoring purposes. Here we focus on resources reflecting the components’ processing capacity, which are specified by the constructor CPUCapacity(r), where r represents the amount of abstract processing resources available between observable points in time. Below, we create three deployment components Server1, Server2, and ClientServer, with the processing capacities 6, 3, and unlimited (i.e., ClientServer has no resource restrictions). The local variables server1, server2, and clientServer refer to these three deployment components, respectively. Objects are explicitly allocated to the servers by annotations; below, object1 is allocated to Server1, etc. { // This main block initializes a static deployment architecture: DC server1 = new DeploymentComponent(\u0026#34;Server1\u0026#34;,set[CPUCapacity(6)]); DC server2 = new DeploymentComponent(\u0026#34;Server2\u0026#34;,set[CPUCapacity(3)]); DC clientServer = new DeploymentComponent(\u0026#34;ClientServer\u0026#34;, EmptySet); [DC: server1] I object1 = new cog C; [DC: server2] I object2 = new cog C; [DC: clientServer] J client1monitor = new cog D(object1); [DC: clientServer] J client2monitor = new cog D(object2); }     The figure depicts this deployment architecture and the artefacts introduced into the modeling language. Since all objects are allocated to a deployment component (which is environment unless overridden by an annotation), we let the expression thisDC() evaluate to the deployment component of an object. For convenience, a call to the method total(\u0026#34;CPU\u0026#34;) of a deployment component returns its total amount of allocated CPU resources. Resource Costs   The available resource capacity of a deployment component determines how much computation may occur in the objects allocated to that component. Objects allocated to the component compete for the shared resources in order to execute, and they may execute until the component runs out of resources or they are otherwise blocked. For the case of CPU resources, the resources of the component define its processing capacity between observable (discrete) points in time, after which the resources are renewed. Cost models   The cost of executing statements in the ABS model is determined by a default value which is set as a compiler option (e.g., defaultcost=10). However, the default cost does not discriminate between statements and we may want to introduce a more refined cost model. For example, if e is a complex expression, then the statement x=e should have a significantly higher cost than skip in a realistic model. For this reason, more fine-grained costs can be inserted into Real-Time ABS models by means of annotations. For example, let us assume that the cost of computing the function f(x) defined in the section on Real-Time ABS may be given as a function g which depends on the size of the input value x. In the context of deployment components, we may redefine the implementation of interface I above to be resource-sensitive instead of having a predefined duration as in the explicit time model. The resulting class C2 can be defined as follows: class C2 implements I { Int m (T x){ [Cost: g(size(x))] return f(x); } }   It is the responsibility of the modeler to specify an appropriate cost model. A behavioral model with default costs may be gradually refined to provide more realistic resource-sensitive behavior. For the computation of the cost functions such as g in our example above, the modeler may be assisted by the COSTABS tool, which computes a worst-case approximation of the cost for f in terms of the input value x based on static analysis techniques, when given the ABS definition of the expression f. However, the modeler may also want to capture resource consumption at a more abstract level during the early stages of system design, for example to make resource limitations explicit before a further refinement of a behavioral model. Therefore, cost annotations may be used by the modeler to abstractly represent the cost of some computation which remains to be fully specified. For example, the class C3 below represents a draft version of our method m in which the worst-case cost of the computation is specified although the function f has yet to be introduced: class C3 implements I { Int m (T x){ [Cost: size(x)*size(x)] return 0; } }  "
},
{
	"uri": "https://abs-models.org/documentation/",
	"title": "Documentation",
	"tags": [],
	"description": "",
	"content": "The ABS language reference is the authoritative guide to what constitutes a legal ABS model, how to specify a Software Product Line, and how to use annotations to model time and resources.\nWe offer tutorials for the ABS language itself, as well as most tools that use ABS as an input language.\n"
},
{
	"uri": "https://abs-models.org/getting_started/editor-support/",
	"title": "Installing Editor Support",
	"tags": [],
	"description": "",
	"content": " We provide support for Emacs, Atom and Visual Studio Code.\nEmacs The abs-mode package provides support for ABS in the Emacs editor.\nInstallation instructions are at https://github.com/abstools/abs-mode.\nAtom The Atom editor support can be found at https://github.com/abstools/language-abs. ABS support for Atom currently cannot be installed from the offical Package repository and has to be installed manually; see https://github.com/abstools/language-abs for instructions.\nVisual Studio Code ABS editing support for Visual Studio Code is at https://github.com/abstools/abs-vs-code. It currently has to be installed manually; see the above page for instructions.\n"
},
{
	"uri": "https://abs-models.org/documentation/tutorials/costabs/",
	"title": "Resource Analysis with CostABS",
	"tags": [],
	"description": "CostABS is a a static analyzer for automatically inferring upper/lower bounds on the worst/best-case Resource usage (a.k.a. cost) of ABS programs.  In this tutorial, we overview the different features of CostABS by example.",
	"content": "  CostABS is a a static analyzer for automatically inferring upper/lower bounds on the worst/best-case Resource usage (a.k.a. cost) of ABS programs. The inferred upper bounds have important applications in the fields of program optimization, verification and certification. CostABS is parametric on the cost model, i.e., the type of cost that the user wants to infer (e.g., number of steps, amount of memory allocated, amount of data transmitted, etc.), and it supports different notions of cost such as sequential, parallel, peak, etc.  In this tutorial, we overview the different features of CostABS by example. All examples are linked to the collaboratory where you can directly replay the steps described in the tutorial. Resource Analysis with SACO   In what follows we present how to use EasyInterface with the different analyses that CostABS is able to perform with some examples.  We first show how to start to use CostABS within the ABS collaboratory. For this, we must first select the analysis in the top pull-down menu, and, for executing the analysis, we click on Run. The Clear button (top right) removes all previous results.  The parameters of the selected analysis can be configured by clicking on the Settings button located in the top-left corner of the EasyInterface page. The results of the selected analysis are presented in the console at the bottom of the screen. This can be done by means of graphs, text messages, markers, highlighters in the code, and interactions among them. In the following, we describe the use of CostABS by analyzing several examples. Basic Resource Analysis   Let us start by performing the basic resource analysis computed by CostABS and described in the paper “SACO: Static Analyzer for Concurrent Objects”. To do it, open the file VendingMachine_init.abs , which contains the following code: module VendingMachine_init; interface VendingMachine { Unit insertCoin(); Unit insertCoins( Int nCoins ); Int retrieveCoins(); } interface PrettyPrinter { Unit showIncome( Int nCoins ); Unit showCoin(); } class IVendingMachine( Int coins, PrettyPrinter out ) implements VendingMachine{ Unit insertCoin(){ coins = coins + 1; } Unit insertCoins( Int nCoins ){ while( nCoins \u0026gt; 0 ){ nCoins = nCoins - 1; Fut\u0026lt;Unit\u0026gt; f = this ! insertCoin(); await f?; } } [coins \u0026lt; max(coins)] Int retrieveCoins(){ Int total = 0; while( coins \u0026gt; 0 ){ coins = coins - 1; Fut\u0026lt;Unit\u0026gt; f = out ! showCoin(); //await f?; total = total + 1; } return total; } } class IPrettyPrinter implements PrettyPrinter{ Unit showIncome( Int nCoins ){ /*Show something*/ } Unit showCoin(){ /*Show something*/ } } class IMain { Unit main( Int n ){ PrettyPrinter o = new IPrettyPrinter(); VendingMachine v = new IVendingMachine( 0, o ); v ! insertCoins(n); Fut\u0026lt;Int\u0026gt; f = v ! retrieveCoins(); await f?; Int total = f.get; o ! showIncome( total ); } }   By selecting Resource Analysis and clicking on Settings a pop-up window appears and shows the configuration that allows us to set up the parameters for the analysis. The following parameters are available:   Cost model  The cost model indicates the type of resource that we are interested in measuring. The user can select among the following cost metrics: termination (only termination is proved), steps (counts the number of executed instructions), objects (counts the number of executed new instructions), tasks (counts the number of asynchronous calls to methods), memory (measures the size of the created data structures), data transmitted (measures the amount of data transmitted among the distributed objects), user-defined model (allows to write annotations in the code of the form [cost == expr] and the analysis accumulates the cost specified by the user in expr every time this program point is visited).   Cost centers  This option allows us to decide whether we want to obtain the cost per cost center (i.e., for each of the abstract objects inferred by the analysis) or a monolithic expression that accumulates the whole computation in the distributed system. The value no refers to the latter case. If we want to separate the cost per cost center, we have again two possibilities. The option class shows the cost of all objects of the same class together, while objectindicates the cost attributed to each abstract object.   Asymptotic bounds  Upper bounds can be displayed in asymptotic or non-asymptotic form. The former one is obtained by removing all constants and subsumed expressions from the non-asymptotic cost, only showing the complexity order.   Symbolic or numeric  Next, if the cost model is memory or objects, the upper bounds can be shown either symbolically, in terms of symbolic sizes (we use size(A) to refer to the size of an object of type A), or numeric, by assigning a predefined measure to them.   Debug  sets the verbosity of the output (the higher the number, the more verbose the output).   Rely Guarantee  performs the resource analysis taking into account the possible interleavings in the tasks execution (as described in the paper “Termination and Cost Analysis of Loops with Concurrent Interleavings”).   Peak Cost Analysis  computes the peak cost analysis for all objects which are identified (see the paper ”Peak Cost Analysis of Distributed Systems”).   Parallel Cost Analysis  computes the parallel cost analysis of the program (see the paper “Parallel Cost Analysis of Distributed Systems”).   Non-cumulative Cost Analysis  computes the non-cumulative cost of the program (see the paper “Non-cumulative Resource Analysis”).   Backend of the Analysis  SACO uses PUBS or CoFloCo as backend to solve the cost equations (see the technical report “Resource Analysis of Complex Programs with Cost Equations”).   Conditional Upper Bounds  computes a set of conditional upper bounds (UBs) according to some conditions on the input parameters (see the technical report “Resource Analysis of Complex Programs with Cost Equations”).   Timed Cost Analysis  computes the cost analysis in time (see this technical report).    Let us analyze the program VendingMachine_init.abs with the default values, except for the Asymptotic bounds parameter that must be set to yes. Click on Refresh Outline and select the entry method (method main of class IMain) in the Outline (the region on the right of the page). Then click on Run to perform the analysis. The result should be shown in the console as follows: Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,max(coins)) = nat(n)+nat(max(coins))   It can be seen in the resource analysis results given by CostABS that the upper bound is linear and it is a function on n (the input parameter of main) and on the maximum value that the field coins can take, denoted max(coins). Variable n is wrapped by function nat previously defined to avoid negative costs. The upper bound is shown in the console view and also at the method’s header when the mouse passes over the marker in line 48 in the program.  Now, let us analyze the main method of the file VendingMachine.abs , which contains the following code: module VendingMachine; interface VendingMachine { Unit insertCoin(); Unit insertCoins( Int nCoins ); Int retrieveCoins(); } interface PrettyPrinter { Unit showIncome( Int nCoins ); Unit showCoin(); } interface Main{ Unit main( Int n ); } class IVendingMachine( Int coins, PrettyPrinter out ) implements VendingMachine{ Unit insertCoin(){ coins = coins + 1; } Unit insertCoins( Int nCoins ){ while( nCoins \u0026gt; 0 ){ nCoins = nCoins - 1; Fut\u0026lt;Unit\u0026gt; f = this ! insertCoin(); await f?; } } Int retrieveCoins(){ Int result = 0; while( coins \u0026gt; 0 ){ coins = coins - 1; Fut\u0026lt;Unit\u0026gt; f = out ! showCoin(); await f?; result = result + 1; } return result; } } class IPrettyPrinter implements PrettyPrinter{ Unit showIncome( Int nCoins ){ /*Show something*/ } Unit showCoin(){ /*Show something*/ } } class IMain implements Main{ Unit main( Int n ){ PrettyPrinter o = new IPrettyPrinter(); VendingMachine v = new IVendingMachine( 0, o ); v ! insertCoins(n); Fut\u0026lt;Int\u0026gt; f = v ! retrieveCoins(); await f?; Int result = f.get; o ! showIncome( result ); } }   This file is just like the previous example, but includes the await instruction at line 37 that was commented out in the previous program. Analyze this program with the same configuration as before: default setting values, except for the asymptotic bounds parameter set to yes. Click on Refresh Outline and select the entry method (method main of class IMain) in the outline. Then click on Run to perform the analysis. The results will be shown like this: Method IMain.main terminates?: UNKOWN UB for 'IMain.main'(this,n) = nat(n)+c(failed(no_rf,[scc=7,cr=entrywhile_1/4]))   The analyzer shows, by using a warning marker (see line 41), that the resource analysis cannot infer an upper bound nor guarantee the termination of the program. Rely-Guarantee Resource Analysis   \u0026lt;div class=\u0026#34;notices info\u0026#34; \u0026gt; NOTE: this analysis is not currently available. \u0026lt;/div\u0026gt;  Let us now perform the rely-guarantee resource analysis, described in the paper ”Termination and Cost Analysis of Loops with Concurrent Interleavings“, on the main method of the VendingMachine.abs file. To do so, we set the option Rely Guarantee to yes and the Cost Model to termination.  After applying the analysis, it can be seen on the default console that CostABS proves that all methods of the program terminate. Let us now slightly modify the example to make method insertCoins non-terminating by removing line 35 with the instruction coins = coins – 1. The analysis information is displayed as follows. For each strongly connected component(SCC) (SCC-while loops and recursive methods are basically the SCCs in a program), the analysis places a marker in the entry line to the SCC. If the SCC is terminating (eg. line 25), by clicking on the marker, the lines that compose this SCC are highlighted in yellow. On the other hand, if the SCC is non-terminating (line 34), by clicking on the marker, CostABS highlights the lines of the SCC in blue. Besides the markers, the list of all SCCs of the program and their computed termination results are printed by CostABS on the console.  At this point, let us perform the rely guarantee resource analysis to infer the cost of the program. Restore the original code of line 35, click on Settings and select the Steps cost model with the option Rely guarantee set to yes. Then click on Run to perform the analysis.  The resulting upper bound obtained is a function in terms on n (the input parameter of main) and in terms of the maximum value that field coins can take, denoted max(coins). We can observe that the cost of main is linear with respect to both. In addition, CostABS shows a marker to the left of each method header to display their corresponding upper bounds. Load Balance   At this point, let us use the resource analysis to study the load balance of the program Performance.abs , which contains the following code: module Parallel; import * from ABS.StdLib; interface I { Unit m (Int n); Unit p (Int n, I x); Unit m2 (Int n); Unit q (); } class C implements I{ Unit m (Int n) { I a = new C(); while (n \u0026gt; 0) { a!p(n, a); n = n - 1; } } Unit mthis (Int n) { I a = new C(); while (n \u0026gt; 0) { a!p(n, this); n = n - 1; } } Unit p (Int n, I x) { while (n \u0026gt; 0) { x!q(); n = n - 1; } } Unit m2 (Int n) { while (n \u0026gt; 0) { I a = new C (); a!p(n, a); n = n - 1; } } Unit q () { skip; } }   As the concurrency unit of ABS is the object, this analysis uses the cost centers to assign the cost of each execution step to the object where the step is performed. We start by applying the Resource Analysis and setting the option Cost Centers to object in the settings. Then click on Refresh Outline and select the method C.m on the right region of the page. Finally, click on Run to perform the analysis. In the console, we see the following output: UB Object Sensitive for C.m(this,n): 6*c([C.m])+nat(n)* (2*c([C.m])+5*c([C.m])+3*c([1,C.m])+nat(n)* (2*c([1,C.m])+5*c([1,C.m])+2*c([1,C.m]))+2*c([1,C.m])+c([1,C.m]))+2*c([C.m])+c([C.m])+c([1,C.m]) UB for cobox ([13,12],C): 1+nat(n)* (6+9*nat(n)) UB for cobox ([12],C.m): 9+7*nat(n)   CostABS returns the cost centers in the program, one cost center labelled with [12] which corresponds to the object that executes C.m and another one labelled with [13,12], which abstracts the object created at line 13. The labels of the nodes contain the program lines where the corresponding object is created. That is, the node labeled as [13,12] corresponds to the C object, created at line 13 while executing the main method, the node identified by line 12. In addition, CostABS shows a graph with both nodes in the Console Graph view at the bottom of the screen. By clicking on the node [12], CostABS shows a dialog box with the upper bound on the number of steps performed by this node. Similarly, by clicking on the node [13,12], it shows the number of steps that can be executed by the object identified with [13,12].  We can observe that the node [12] performs a number of steps that is bounded by a linear function on the input parameter n, while in the node [13,12] the number of steps is bounded by a quadratic function on n. If we analyze method C.mthis, the cost is distributed in a different way. In this case, both nodes [20] and [21,20] have a quadratic upper bound on the number of steps performed by each node. The difference between both methods is that the call x!q() at line 30 is performed in object [13,12] in the former case, and in object [20] in the latter.  We can obtain the number of instances of each object we can have in each node. Select C.m2 and unselect the previously selected methods on the outline on the right of the page, and perform the Resource Analysis, setting the options Cost Model to Objects and Cost Centers to Object. It can be seen in the output of CostABS that the number of instances of the object identified by [37,35] is bounded by n (the input argument of method m2). Finally, we can apply the resource analysis to C.m2 selecting Cost Model to Steps to obtain the results of the analysis for this method regarding the number of steps. Transmission Data Sizes   Now, let us perform the transmission data size analysis to the following code: module DemoTraffic; import * from ABS.StdLib; interface II { Unit work (Int n, List\u0026lt;Int\u0026gt; l); } interface IS { Int process (List\u0026lt;Int\u0026gt; l); } class Master (IS s) implements II { Unit work (Int n, List\u0026lt;Int\u0026gt; l){ while (n\u0026gt;0) { l = Cons(1,l); Fut\u0026lt;Int\u0026gt; q = s!process(l); q.get; n = n - 1; } } } class Slave () implements IS{ Int process (List\u0026lt;Int\u0026gt; l) {return 1;} } class IMain { Unit main (List\u0026lt;Int\u0026gt; l, Int n) { IS s = new Slave(); II m = new Master(s); m!work(n,l); } }   Open the file DataTransmitted.abs . To analyze this file with the transmission data size analysis, select the analysis Resource Analysis (SACO) and set the option Cost Model to Traffic. Then refresh the outline and apply the analysis to the method IMain.main.  When the analysis is applied, the console will show the upper bound expressions for all possible pairs of objects identified by the analysis: UB Object Sensitive for IMain.main(this,l,n): c(o([IMain.main],[2,IMain.main],Master.work))* (1+c(i)+nat(l))+c(o([2,IMain.main],[IMain.main],Master.work))* (1+c(i))+c(o([IMain.main],[2,IMain.main],Master.init))* (1+c(i))+c(o([2,IMain.main],[IMain.main],Master.init))*c(i)+c(o([IMain.main],[1,IMain.main],Slave.init))*c(i)+c(o([1,IMain.main],[IMain.main],Slave.init))*c(i)+nat(n)* (c(o([2,IMain.main],[1,IMain.main],Slave.process))* (c(i)+nat(l+2*n))+c(o([1,IMain.main],[2,IMain.main],Slave.process))* (1+c(i))) UB for interactions between ([31],[32,31]): c(i) UB for interactions between ([31],[33,31]): 2+nat(l)+2*c(i) UB for interactions between ([33,31],[32,31]): nat(n)* (c(i)+nat(l+2*n)) UB for interactions between ([32,31],[31]): c(i) UB for interactions between ([33,31],[31]): 1+2*c(i) UB for interactions between ([32,31],[33,31]): nat(n)* (1+c(i))   For example, the last line of the console output is the upper bound of the size of the data transmitted from the node [32,31] to the node [33,31], that are the Slave and Master objects created at line 32 and line 33, respectively. We can observe that this upper bound linearly depends on the input parameter n, which is the number of times the method process in the Slave object is invoked. On the other hand, the data transmitted from the Master object [33,31] to the Slave object [32,31] is different, as the invocation contains the list l which is passed as argument to the method process. In this case, the upper bound is a quadratic function on the parameter n, as the list passed as argument grows at each iteration of the loop at line 16, and this loop iterates n times.  In addition to the console information, the graph in output tab Console Graph shows the objects creation. By clicking on a node in the graph, a message outputs the UBs (upper bounds) for all transmissions data sizes that the selected object can perform and the objects involved in such transmissions. For example, by clicking on the node [32,31], which corresponds to the Master object, we can see the upper bounds on the data transmitted (incoming and outgoing transmissions) from this object. As before, the labels of the nodes contain the program lines where the corresponding object is created. For instance, the node labeled as [32,31] corresponds to the Master object, created at line 32 while executing the main method, the object identified by line 31. In such upper bounds, the cost expression c(i) represents the cost of establishing the communication. Non-Cumulative Cost   We can illustrate the analysis for computing the non-cumulative cost with the file Noncumulative.abs , which contains the following code: module Noncumulative; import * from ABS.StdLib; class IMain { Unit main (Int s, Int n) { [x == acquire(10)] Int i= 0; [r == acquire(100)] i = 0; [r == acquire(s)] i = 1; [r == release()] i = 2; [y == acquire(n)] i = 3; [x == release()] i = 4; } }   In Settings, restore the default values and set the option noncumulative_cost to yes. Then refresh the outline and select the method IMain.main. The results obtained after clicking Run show that we have two sets of program points that can lead to the maximum on the number of resources acquired, as well as their corresponding upper bound expressions. The set [L6,L8,L10] corresponds to the acquireinstructions at lines 6, 8 and 10 of the program. With this set of acquire instructions, we obtain an upper bound of the number of resources that linearly depends on the input parameter s because of the acquire at line 10. The set [L6,L8,L14] can also lead to the maximum number of resources acquired, if the actual value of the input parameter n is larger than s. Peak Cost Analysis   Let us continue by performing the peak cost analysis to the program VendingMachine_init.abs . Similarly to other analyses, we first select the entry method (method main in class IMain) in the outline view and start the Resource Analysis (SACO) with default options, with the exception of the option Peak Cost, which must be set to yes. After clicking Run, the peak cost analysis outputs in the console. Closure time 2 ms. Direct mhp time 0 ms. Indirect mhp time 24 ms. Configurations found for queue [49,48] -- IPrettyPrinter.showIncome,IPrettyPrinter.showCoin -- IPrettyPrinter.init UBs for the configurations of queue [49,48] -- UB_k for [49,48]-[IPrettyPrinter.showIncome,IPrettyPrinter.showCoin]): 2+2*nat(max(coins)-1) -- UB_k for [49,48]-[IPrettyPrinter.init]): 0 Configurations found for queue [50,48] -- IVendingMachine.insertCoins,IVendingMachine.retrieveCoins,IVendingMachine.insertCoin -- IVendingMachine.init UBs for the configurations of queue [50,48] -- UB_k for [50,48]-[IVendingMachine.insertCoins,IVendingMachine.retrieveCoins,IVendingMachine.insertCoin]): 13+14*nat(n)+13*nat(max(coins)-1) -- UB_k for [50,48]-[IVendingMachine.init]): 0   For each identified ABS object, all possible queue configurations are shown. A queue configuration is the set of tasks that can be in the task queue simultaneously. For each queue configuration, the tasks involved in the configuration are shown. In addition, the total cost associated with the configuration is displayed as well.  The analysis of the program VendingMachine_init.abs shows that there are two possible queue configurations for each object identified in the program. For example, for the object [49,48] one of the configurations contains tasks for methods showIncome and showCoin, and the number of steps executed by those tasks linearly depends on the value of the field coins.  As before, the output tab Console Graph also shows a graph where the labels of the nodes contain the program lines where the corresponding object is created. For instance, the node labeled as [49,48] corresponds to the PrettyPrinter object, created at line 49 while executing the main method which starts at line 48. By clicking on a node, the queue configurations that have been identified and their costs are shown in a message. Parallel Cost   Let us perform the parallel cost analysis described in the paper “Parallel Cost Analysis of Distributed Systems”. To do so, we open the file Parallel.abs , which contains the following code: module Parallel; import * from ABS.StdLib; interface IX { Unit p (IY y); } interface IY { Unit q (); Unit s (); } class X implements IX { Unit p (IY y) { skip; y!s(); Int method_end = 0; } } class Y implements IY { Unit q () { Int method_end = 0; } Unit s () { Int method_end = 0; } } class IMain { Unit main () { IX x = new X (); IY y = new Y (); x!p(y); skip; y!q(); Int method_end = 0; } }   Select the entry method IMain.main in the outline and apply the Resource Analysis by restoring the default values and setting the option Parallel Cost to yes. The analysis results show the computed upper bound expressions obtained for all paths identified in the DFG (distributed flow graph) of the program. In addition, the result shows the number of nodes and edges of the computed DFG. Closure time 1 ms. Direct mhp time 0 ms. Indirect mhp time 3 ms. DFG Number of Nodes: 11 DFG Number of Edges: 12 DFG Number of Exit nodes: 4 Number of Paths found: 16 The Parallel Cost for IMain.main(this) is the maximum of the expressions (4): UB Expression: 10 UB Expression: 14 UB Expression: 13 UB Expression: 9  Cost Analysis in Time   Let us continue by performing the cost analysis in time to the program in Timed.abs , with the following code: module Timed; interface Job{ Unit start(Int dur); } class IMain{ Unit main(Int n){ while(n\u0026gt;0){ Job job=new local Job(); job!start(10);\tawait duration(1,1); n= n-1; } } } class Job implements Job{ Unit start(Int dur){ while(dur\u0026gt;0){ [Cost: 1] dur=dur-1; await duration(1,1); } } }   Select the entry method IMain.main in the outline of the program. Then, select the Resource Analysis and set the option Timed Cost to yes. After applying the analysis, the output of SACO shows Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = n*c(condition([[1*time=1,-1*n+1*_G13533=1,-1*target= -9,1*_G13533=2,-1*_G13533+1*target=0]])) Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = 0*c(condition([[1*time=1,-1*n+1*_G13533=1,1*_G13533=2,-1*_G13533+1*target=9],[1*time=1,1*_G13533=1,-1*n=0,1*target=1]])) Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = 1*c(condition([[1*time=1,1*target=1,-1*n+1*_G13542=1,1*_G13542=3],[1*time=1,-1*n+1*_G13542=1,-1*target+1*_G13542= -8,1*_G13542=2],[1*n=1,1*time=1,1*target=1,1*_G13542=2]])) Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = 9*c(condition([[1*time=1,-1*n+1*_G13533=1,1*target=11,-1*target+1*_G13533= -7,-1*_G13533+1*target=0],[1*time=1,1*target=10,-1*n+1*_G13533=1,-1*_G13533= -10,1*_G13533=3]])) Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = 10*c(condition([[1*time=1,-1*n+1*_G13533=1,1*target=11,-1*target+1*_G13533=2],[1*time=1,1*target=10,-1*n+1*_G13533=1,1*_G13533=12]])) Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = 11*c(condition([[1*time=1,-1*target+1*n=0,-1*_G13545+1*n= -1,1*n=11],[1*n=10,1*time=1,1*target=10,1*_G13545=11]])) Method IMain.main terminates?: YES UB for 'IMain.main'(this,n,time,target) = (n+1)*c(condition([[1*time=1,-1*n+1*_G13536=1,-1*target= -9,1*target=2,-1*target+1*_G13536=2],[1*time=1,-1*target+1*n=0,-1*_G13536+1*n= -1,-1*n= -9,1*n=2]]))  CoFloCo Backend   Finally, let us analyze the program CoFloCoExample.abs by using CoFloCo as backend. In this case, the file contains the following code: module Parallel; import * from ABS.StdLib; class C { Bool nondet=False; Unit m1 (Int i, Int dir, Int n) { while (0\u0026lt;i \u0026amp;\u0026amp; i \u0026lt; n) { if (dir == 1) { i = i + 1; } else { i = i - 1; } } } Unit m2 (Int x, Int y, Int a, Int r) { while (x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0) { if (nondet) { x = x - 1; y = r; } else { y = y - 1; } suspend; } } Unit m3 (Int x, Int y, Int a) { while (x \u0026gt; 0) { while (y \u0026gt; 0 \u0026amp;\u0026amp; nondet) { y = y - 1; suspend; } x = x - 1; } } }   We can select the method of interest, that is, C.m, C.m2 or C.m3 and then perform the resource analysis with the default options except the option Backend, which must be set to CoFloCo. After applying the analysis, SACO shows the results of the analysis of C.m with CoFloCo. "
},
{
	"uri": "https://abs-models.org/documentation/tutorials/mhp/",
	"title": "May-Happen-in-Parallel Analysis",
	"tags": [],
	"description": "The maypar static analysis tool finds pairs of program statements that possibly execute in parallel.",
	"content": " May-Happen-in-Parallel Analysis (MHP)   ABS is a distributed language where different methods can be invoked asynchronously. Therefore, there can be several tasks executing their code at the same time. This simultaneity complicates the analysis and understanding of ABS programs, since (in general) there is a high level of parallelism. The MHP analysis alleviates this situation by computing, for each instruction, which other instructions could execute in parallel. This information can be very interesting for developers and testers, but it is crucial for the precision of many of the SACO analyses presented in the CostABS tutorial.  The result of the MHP analysis, described in the paper “Analysis of May-Happen-in-Parallel in Concurrent Objects”, is a set of pairs of instructions that could execute in parallel in any execution of the program. It is important to stress that this analysis computes an overapproximation of the parallelism. In other words, if a pair of instruction can execute in parallel, then they will be detected by the analysis; however, the analysis can incorrectly detect pairs of instructions that never execute in parallel when executing the program. MHP Analysis in the Collaboratory   In order to apply the MHP Analysis in the Collaboratory, just:    Open the ABS program to analyze.    Select MHP Analysis in the list of analyses.    Refresh the list of methods in the right side (button Refresh Outline) and select the entry point of the analysis. Only one method or function can be selected as entry point. If none is selected then the main block will be considered the entry point.    Press the Run button.    Let us see the results of the MHP analysis in the VendingMachine.abs program selecting the main method from class IMain as the entry point. The analysis reports its results in two places. First, all the pairs of instructions that can be executed in parallel are printed in the console. This information is very detailed and verbose, but difficult to understand: ... L28 (Await)[IVendingMachine.insertCoins(-[2,'IMain.main']-)] || L37 (Await)[IVendingMachine.retrieveCoins(-[2,'IMain.main']-)] L20 (Entry)[IVendingMachine.insertCoin(-[2,'IMain.main']-)] || L60 (Exit)[IMain.main(-['IMain.main']-)] ...   The previous fragment shows that the instruction at L28 (the await instruction in method insertCoins) can happen in parallel with the instruction at L37 (the await instruction in method retrieveCoins), and the same for instructions at L20 and L60. However, the most comfortable way of inspecting the results of the MHP analysis is by navigating the code. Every considered instruction will have a blue arrow in its left margin. When clicking the arrow of an instruction, all the other considered instructions that can happen in parallel with it will be highlighted in yellow. For example, clicking on the arrow in L37 will show the instructions that can happen in parallel with it, which as expected include L28. We have mentioned “considered instruction” because, by default, the MHP analysis only takes into account those instructions that are entry/exit points of methods and await or release instructions. In order to obtain the full list of instructions that may happen in parallel, open the settings window (button Settings, option MHP analysis) and change the option Amount of considered points from Reduced to Full. With these new settings the analysis obtains the MHP information for all the instructions in the program.  Since the MHP analysis is a sound overapproximation, instructions that cannot execute in parallel are never detected. For example, due to the await instruction at L57, the task retrieveCoins must be finished before continuing. Therefore, the await instruction at L37, which is inside retrieveCoins, cannot happen in parallel with the instructions after the await (L58 and L59) or the method showIncome that is invoked at L59. If we execute a full MHP analysis and select the arrow at L37, those fragments will not be highlighted. MHP Settings   In addition to the Amount of considered points to compute all the pairs of instructions that can execute in parallel or only a the most important, the MHP analysis supports other important settings, as shown in the next figure:    Using these parameters we can adapt the behavior of the analysis:    Debug information (0, 1, or 2): level of information that is printed in the console, where 0 is the lowest level.    Points-to analysis precision (1, 2, 3 and 4): the precision that will be used in the point-to analysis that approximates the different objects that are created during execution.    Condition synchronization MHP extension (no, yes): by default, the MHP analysis only considers simple await instructions involving one future variable (await f?;). When enabling this option, the analysis tries to use the information from await instructions that involve complex conditions like await this.x != null.    Inter-Procedural Synchronization (no, yes): enables a refinement of the MHP analysis that obtains finer information about the finished task, thus producing more precise results in programs with inter-procedural synchronization.   May-Happen-in-Parallel with Inter-Procedural Synchronization   Let us analyze with SACO the program InterProcedural.abs with the Inter-Procedural Synchronization of the MHP analysis (described in the paper May-Happen-in-Parallel Analysis for Asynchronous Programs with Inter-Procedural Synchronization), as mentioned before. module Parallel; import * from ABS.StdLib; interface IO1 { Unit f (); } interface IO2 { Unit g (Fut\u0026lt;Unit\u0026gt; w); } class O1 implements IO1 { Unit f () { skip; } } class O2 implements IO2 { Unit g (Fut\u0026lt;Unit\u0026gt; w) { skip; await w?; skip; } } { Fut\u0026lt;Unit\u0026gt; x; Fut\u0026lt;Unit\u0026gt; y; IO1 o1 = new local O1(); IO2 o2 = new local O2(); x = o1!f(); y = o2!g(x); await y?; }   If we apply the MHP analysis without inter-procedural synchronization, we obtain that L14 can happen in parallel with L34 because the analysis is not able to infer that when method g finishes its execution, method f has finished too (caused by the await instruction in L21).  To refine the MHP analysis, we set the option Inter-Procedural Synchronization to yes. Using this refinement we obtain that the only program points that can happen in parallel with L34 are the end of methods f and g, which means that both methods must have finished when L34 is reached. "
},
{
	"uri": "https://abs-models.org/publications/",
	"title": "Selected Publications",
	"tags": [],
	"description": "",
	"content": " This page contains selected research papers on the development and usage of the ABS modeling language and analysis tools.\nCase Studies  E. Albert, F. de Boer, R. Hähnle, E. B. Johnsen, R. Schlatte, S. L. Tapia Tarifa, P. Y. H. Wong.\nFormal modeling and analysis of resource management for cloud architectures: an industrial case study using Real-Time ABS.\nService Oriented Computing and Applications 8 (4):323-339, 2014.\nDOI: 10.1007/s11761-013-0148-0. Download a preprint.\n J-C Lin, I. C. Yu, E. B. Johnsen, M-C Lee.\nABS-YARN: A Formal Framework for Modeling Hadoop YARN Clusters.\nProc. 19th Intl. Conf. on Fundamental Approaches to Software Engineering (FASE 2016). LNCS 9633. Springer, 2016.\nDOI: 10.1007/978-3-662-49665-7_4. Download a preprint.\n  Language Development  E. B. Johnsen, R. Hähnle, J. Schäfer, R. Schlatte, and M. Steffen.\nABS: A Core Language for Abstract Behavioral Specification.\nIn Proc. 9th Intl. Symp. on Formal Methods for Components and Objects (FMCO 2010), LNCS 6957. Springer , 2011.\nDOI: 10.1007/978-3-642-25271-6_8. Download a preprint.\n E. B. Johnsen, R. Schlatte, and S. L. Tapia Tarifa.\nIntegrating Deployment Architecture and Resource Consumption in Timed Object-Oriented Models.\nJournal of Logical and Algebraic Methods in Programming 84(1): 67-91, 2015.\nDOI: 10.1016/j.jlamp.2014.07.001. Download a preprint.\n F. Damiani, R. Hähnle, E. Kamburjan, M. Lienhardt.\nA Unified and Formal Programming Model for Deltas and Traits.\nProc. 20th International Conference on Fundamental Approaches to Software Engineering (FASE 2017), LNCS 10202. Springer, 2017.\nDOI: 10.1007/978-3-662-54494-5_25. Download a postprint.\n  Software Product Lines  F. Damiani, M. Lienhardt, R. Muschevici, I. Schaefer.\nAn Extension of the ABS Toolchain with a Mechanism for Type Checking SPLs. Proc. 13th International Conference on Integrated Formal Methods (IFM 2017), LNCS 10510. Springer, 2017.\nDOI: 10.1007/978-3-319-66845-1_8. Download a postprint.  Deductive Verification  C. C. Din, R. Bubel and R. Hähnle.\nKeY-ABS: A Deductive Verification Tool for the Concurrent Modelling Language ABS.\nIn Proc. 25th Intl. Conf. on Automated Deduction (CADE 2015), LNCS 9195. Springer, 2015.\nDOI:10.1007/978-3-319-21401-6_35. Download a preprint.\n C. C. Din, S. L. Tapia Tarifa, R. Hähnle and E. B. Johnsen.\nHistory-Based Specification and Verification of Scalable Concurrent and Distributed Systems.\nIn Proc. 17th Intl. Conf. on Formal Engineering Method (ICFEM 2015), LNCS 9407. Springer, 2015.\nDOI: 10.1007/978-3-319-25423-4_14. Download a preprint.\n  Cost Analysis  E. Albert, P. Arenas, A. Flores-Montoya, S. Genaim, M. Gómez-Zamalloa, E. Martin-Martin, G. Puebla, and G. Román-Díez.\nSACO: Static Analyzer for Concurrent Objects.\nIn Proc. 20th Intl. Conf. on Tools and Algorithms for the Construction and Analysis of Systems (TACAS). LNCS 8413, Springer, 2014.\nDOI: 10.1007/978-3-642-54862-8_46. Download a preprint.  Deadlock Analysis  E. Giachino, C. Laneve, and M. Lienhardt.\nA Framework for Deadlock Detection in ABS.\nJournal of Software and Systems Modeling, to appear, 2015.\nDOI: 10.1007/s10270-014-0444-y. Download a preprint.  Code Generation from ABS  B. Nobakht and F. S. de Boer.\nProgramming with Actors in Java 8.\nIn Proc. of the 6th Intl. Symposium on Leveraging Applications of Formal Methods, Verification and Validation (ISoLA’14). LNCS 8803. Springer, 2014.\nDOI: 10.1007/978-3-662-45231-8_4. Download a preprint.  Model-based Deployment and Monitoring  R. Hähnle and E. B. Johnsen.\nDesigning Resource-Aware Cloud Applications.\nIEEE Computer 48 (6), 2015.\nDOI: 10.1109/MC.2015.172. Download a preprint.\n B. Nobakht, S. de Gouw and F.S. de Boer.\nFormal Verification of Service Level Agreements Through Distributed Monitoring.\nIn Proc. 4th European Conf. on Service Oriented and Cloud Computing (ESOCC 2015). LNCS 9306, Springer, 2015.\nDOI: 10.1007/978-3-319-24072-5_9. Download a preprint.\n  "
},
{
	"uri": "https://abs-models.org/documentation/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " This page features a list of tutorials for most tools that work with the ABS language.\nConverted Tutorials Conversion from old tutorials is on-going and help is most welcome.\n Language Tutorial  This tutorial gives an overview of the ABS language.\n Resource Modeling Tutorial  An introduction to time and resource modeling in ABS.\n Resource Analysis with CostABS  CostABS is a a static analyzer for automatically inferring upper/lower bounds on the worst/best-case Resource usage (a.k.a. cost) of ABS programs. In this tutorial, we overview the different features of CostABS by example.\n May-Happen-in-Parallel Analysis  The maypar static analysis tool finds pairs of program statements that possibly execute in parallel.\n Resource Analysis with SRA  We prototype a static analysis technique that computes upper bounds of virtual machine usages in a dialect of ABS called vml.\n Envisage / HATS Tutorials These tutorials were written during the Envisage and HaTS projects. The pdfs are provided as-is and might contain outdated information.\nInstallation Tutorial\nEasyInterface Tutorial\nResource Tutorial\nResource Analysis (SACO) Tutorial\nResource Analysis (SRA) Tutorial\nDeadlock Analysis (SACO) Tutorial\nDeadlock Analysis (SRA) Tutorial\nSystematic Testing (SYCO) \u0026amp; Test Case Generation (aPET) Tutorial\nSmart Deployer Tutorial\nKeY-ABS Tutorial\nModelling Auto-scalable Services Tutorial\n"
},
{
	"uri": "https://abs-models.org/documentation/tutorials/sra/",
	"title": "Resource Analysis with SRA",
	"tags": [],
	"description": "We prototype a static analysis technique that computes upper bounds of virtual machine usages in a dialect of ABS called vml.",
	"content": " General Overview We prototype a static analysis technique that computes upper bounds of virtual machine usages in a dialect of ABS, called vml, whose syntax will be covered by the examples in this tutorial, with explicit acquire and release operations of virtual machines. In our language it is possible to delegate other (ad-hoc or third party) concurrent code to release virtual machines (by passing them as arguments of invocations). Our technique is modular and consists of (i) a type system associating programs with behavioural types that records relevant information for resource usage (creations, releases, and concurrent operations), (ii) a translation function that takes behavioural types and return cost equations. It is integrated with the solver CoFloCo that given the cost equations produces the result.\nResource Analysis In this section we present how to compute the cost of a vml program in term of virtual machine usage.\nFirst, select Resource Analysis (SRA) from the pull-down menu at the top of the window on the center-left. The parameters of the selected analysis are automatically set, so there is nothing to be configured in the Settings section in the top-left corner.\nAs an example, open the program doubleRelease.vml :\n/* DOUBLE RELEASE */ Int doubleRelease(VM x, VM y) { release x; release y; return 0 ; } Int user1() { VM x ; VM y ; Fut\u0026lt;Int\u0026gt; f ; x = new VM() ; y = new VM(); f = this!doubleRelease(x, y); Int a = f.get ; return 0 ; } { Fut\u0026lt;Int\u0026gt; fuser1 = this!user1(); Int a = fuser1.get; }  Let us analyze the program. Click on Run to perform the analysis.\nThe output of the analysis is shown in three tabs of the console, which are generated by the tool:\n Types contains the behavioural types generated for the input program Equations contains the cost equations resulted by the translation of the behavioural types UBs which is the overall output and shows the upper bounds. For the doubleRelease.vml we get:\n### Partitioned upper bound of main(MAINVM): * 2 if [] ### Partitioned upper bound of doubleRelease012net(THISVM,X,Y): * -2 if [THISVM=1,X=1,Y=1] * -1 if [THISVM=1,X=1,Y\u0026gt;=2] or [THISVM=1,Y=1,X\u0026gt;=2] * 0 if [THISVM=1,X\u0026gt;=2,Y\u0026gt;=2] or [THISVM=3] ### Partitioned upper bound of user10net(THISVM): * 0 if [3\u0026gt;=THISVM,THISVM\u0026gt;=1] ### Partitioned upper bound of doubleRelease012peak(THISVM,X,Y): * 0 if [X=1,Y=1,2\u0026gt;=THISVM] * 0 if [X=1,2\u0026gt;=THISVM,Y\u0026gt;=2] or [Y=1,2\u0026gt;=THISVM,X\u0026gt;=2] or [X=1,2\u0026gt;=THISVM,0\u0026gt;=Y] * 0 if [2\u0026gt;=THISVM,X\u0026gt;=2,Y\u0026gt;=2] or [2\u0026gt;=THISVM,0\u0026gt;=Y,X\u0026gt;=2] or [3\u0026gt;=THISVM,0\u0026gt;=X] or [THISVM=3,X\u0026gt;=1] ### Partitioned upper bound of user10peak(THISVM): * 0 if [THISVM=3] * 2 if [2\u0026gt;=THISVM]   "
},
{
	"uri": "https://abs-models.org/contact/",
	"title": "Contact",
	"tags": [],
	"description": "",
	"content": "We welcome bug reports and feature requests submitted via github.\nTo contact the maintainers, write to abs-info@abs-models.org.\nSubscribe to the developers’ mailing list at the developer list manager page. Subscribe to a low-traffic announcement-only list at the announcement list manager page.\n"
},
{
	"uri": "https://abs-models.org/acknowledgments/",
	"title": "Acknowledgments",
	"tags": [],
	"description": "",
	"content": " Projects The development of the ABS language and tools has been supported by a number of European FP7 and H2020 research projects.\n HATS: Highly Adaptive and Trustworthy Software using Formal Methods\n Envisage: Engineering Virtualized Services\n HyVar: Scalable Hybrid Variability\n  Contributors The following people have contributed to the ABS language and tools so far:\n Elvira Albert Ade Azurat Nikolaos Bezirgiannis Joakim Bjørk Frank de Boer Richard Bubel Dave Clarke Jesús Correas Ferruccio Damiani Crystal Chang Din Antonio Flores-Montoya Abel Garcia Samir Genaim Elena Giachino Miguel Gómez-Zamalloa Georg Göri Stijn de Gouw Reiner Hähnle Einar Broch Johnsen Eduard Kamburjan Ivan Lanese Cosimo Laneve Michael Lienhardt Kelly Lin Enrique Martin-Martin Jacopo Mauro Radu Muschevici Behrooz Nobakht Olaf Owe Björn Petersen Germán Puebla Violet Ka I Pun Guillermo Román-Díez Ina Schaefer Rudi Schlatte Vlad Serbanescu Faiza Shehzad Oliver Stahl Martin Steffen Volker Stolz S. Lizeth Tapia Tarifa Lars Tveito Peter Y.H. Wong Ingrid Chieh Yu Miky Zamalloa Gianluigi Zavatarro  "
},
{
	"uri": "https://abs-models.org/laboratory/",
	"title": "The Collaboratory",
	"tags": [],
	"description": "",
	"content": "The Collaboratory is a browser-based IDE for ABS that offers an online, zero install version of the ABS toolchain. Use it to experiment with the language in a risk-free environment.\nLoad our ready-made examples or run your own ABS models. The editor has many features of an IDE, including showing you an outline of the code, and of course reporting syntax- and type errors.\nThe collaboratory also supports many of the analysis tools that we have developed, like COSTA and SACO.\nA collaboratory instance is hosted online at http://ei.abs-models.org:8082/clients/web/. Please use this instance responsibly, and consider running the collaboratory on your local machine.\nTo run a private local instance of the collaboratory, see Running a Browser-Based IDE.\n"
},
{
	"uri": "https://abs-models.org/",
	"title": "The ABS Language",
	"tags": [],
	"description": "",
	"content": " The ABS Language ABS is a language for Abstract Behavioral Specification, which combines implementation-level specifications with verifiability, high-level design with executablity, and formal semantics with practical usability. ABS is a concurrent, object-oriented, modeling language that features functional data-types.\n ABS is designed to develop executable models with an object-oriented program flow ABS targets distributed and concurrent systems by means of concurrent object groups and asynchronous method calls ABS supports model variability based on delta-oriented specifications ABS supports deployment modelling based on high-level deployment models ABS supports a range of techniques for model exploration and analysis, based on formal semantics  Overview\nGetting Started\nThe Language Manual\nTutorials\nPublications\nContact\nAcknowledgments\n"
},
{
	"uri": "https://abs-models.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://abs-models.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]